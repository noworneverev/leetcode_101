"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[1787],{7315:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"two-pointer-techniques/2-2-two-sum","title":"2.2 Two Sum","description":"167. Two Sum II - Input array is sorted","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/2-two-pointer-techniques/2-2-two-sum.mdx","sourceDirName":"2-two-pointer-techniques","slug":"/two-pointer-techniques/2-2-two-sum","permalink":"/leetcode_101/en/two-pointer-techniques/2-2-two-sum","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/2-two-pointer-techniques/2-2-two-sum.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"2.1 \u7b97\u6cd5\u89e3\u91ca","permalink":"/leetcode_101/en/two-pointer-techniques/2-1-algorithm-explanation"},"next":{"title":"2.3 Merging Two Sorted Arrays","permalink":"/leetcode_101/en/two-pointer-techniques/2-3-merge-sorted-arrays"}}');var o=n(4848),i=n(8453);const s={sidebar_position:6},a="2.2 Two Sum",l={},h=[{value:"167. Two Sum II - Input array is sorted",id:"167-two-sum-ii---input-array-is-sorted",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components},{TabItem:n,Tabs:r}=t;return n||c("TabItem",!0),r||c("Tabs",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"22-two-sum",children:"2.2 Two Sum"})}),"\n",(0,o.jsx)(t.h2,{id:"167-two-sum-ii---input-array-is-sorted",children:(0,o.jsx)(t.a,{href:"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",children:"167. Two Sum II - Input array is sorted"})}),"\n",(0,o.jsx)(t.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,o.jsx)(t.p,{children:"Find two numbers in an ascending integer array such that their sum equals a given value. There is exactly one solution."}),"\n",(0,o.jsx)(t.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,o.jsxs)(t.p,{children:["The input is an array (",(0,o.jsx)(t.code,{children:"numbers"}),") and a target value (",(0,o.jsx)(t.code,{children:"target"}),"). The output is the positions of the two numbers, starting from 1."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Input: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\n"})}),"\n",(0,o.jsx)(t.p,{children:"In this example, the sum of the first number (2) and the second number (7) equals the target value (9)."}),"\n",(0,o.jsx)(t.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,o.jsx)(t.p,{children:"Since the array is sorted, we can use a two-pointer approach with pointers moving in opposite directions to find these two numbers. One pointer starts at the smallest element, on the far left of the array, moving right; the other starts at the largest element, on the far right of the array, moving left."}),"\n",(0,o.jsx)(t.p,{children:"If the sum of the elements pointed to by the two pointers equals the target, then they are the solution. If the sum is less than the target, we move the left pointer one position to the right to increase the sum. If the sum is greater than the target, we move the right pointer one position to the left to decrease the sum."}),"\n",(0,o.jsxs)(t.p,{children:["It can be proven that for a sorted array with a solution, the two-pointer approach will always reach the optimal solution. Here\u2019s the proof: Assume the positions of the solution are ",(0,o.jsx)(t.code,{children:"l"})," and ",(0,o.jsx)(t.code,{children:"r"}),". If the left pointer is to the left of ",(0,o.jsx)(t.code,{children:"l"})," and the right pointer has already moved to ",(0,o.jsx)(t.code,{children:"r"}),", the sum of the two values will be less than the target, so the left pointer will continue moving right until it reaches ",(0,o.jsx)(t.code,{children:"l"}),". Similarly, if the right pointer is to the right of ",(0,o.jsx)(t.code,{children:"r"})," and the left pointer has already moved to ",(0,o.jsx)(t.code,{children:"l"}),", the sum will be greater than the target, so the right pointer will move left until it reaches ",(0,o.jsx)(t.code,{children:"r"}),". Thus, the two pointers will converge at ",(0,o.jsx)(t.code,{children:"l"})," and ",(0,o.jsx)(t.code,{children:"r"}),", as no other scenario prevents this convergence."]}),"\n",(0,o.jsxs)(r,{children:[(0,o.jsx)(n,{value:"cpp",label:"C++",children:(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cpp",children:"vector<int> twoSum(vector<int>& numbers, int target) {\n    int l = 0, r = numbers.size() - 1, two_sum;\n    while (l < r) {\n        two_sum = numbers[l] + numbers[r];\n        if (two_sum == target) {\n            break;\n        }\n        if (two_sum < target) {\n            ++l;\n        } else {\n            --r;\n        }\n    }\n    return vector<int>{l + 1, r + 1};\n}\n"})})}),(0,o.jsx)(n,{value:"py",label:"Python",children:(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-py",children:"def twoSum(numbers: List[int], target: int) -> List[int]:\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        two_sum = numbers[l] + numbers[r]\n        if two_sum == target:\n            break\n        if two_sum < target:\n            l += 1\n        else:\n            r -= 1\n    return [l + 1, r + 1]\n"})})})]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}function c(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);