"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[7975],{9164:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"divide-and-conquer/7-2-expression-problems","title":"7.2 Expression Problems","description":"241. Di\ufb00erent Ways to Add Parentheses","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/7-divide-and-conquer/7-2-expression-problems.mdx","sourceDirName":"7-divide-and-conquer","slug":"/divide-and-conquer/7-2-expression-problems","permalink":"/leetcode_101/en/divide-and-conquer/7-2-expression-problems","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":36,"frontMatter":{"sidebar_position":36},"sidebar":"tutorialSidebar","previous":{"title":"7.1 Algorithm Explanation","permalink":"/leetcode_101/en/divide-and-conquer/7-1-algorithm-explanation"},"next":{"title":"7.3 Exercises","permalink":"/leetcode_101/en/divide-and-conquer/7-3-exercises"}}');var r=i(4848),t=i(8453);const o={sidebar_position:36},a="7.2 Expression Problems",d={},p=[{value:"241. Di\ufb00erent Ways to Add Parentheses",id:"241-di\ufb00erent-ways-to-add-parentheses",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...n.components},{TabItem:i,Tabs:s}=e;return i||u("TabItem",!0),s||u("Tabs",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"72-expression-problems",children:"7.2 Expression Problems"})}),"\n",(0,r.jsx)(e.h2,{id:"241-di\ufb00erent-ways-to-add-parentheses",children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/different-ways-to-add-parentheses/",children:"241. Di\ufb00erent Ways to Add Parentheses"})}),"\n",(0,r.jsx)(e.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,r.jsx)(e.p,{children:"Given a mathematical expression containing addition, subtraction, and multiplication, find all possible results by adding parentheses in different ways."}),"\n",(0,r.jsx)(e.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,r.jsx)(e.p,{children:"The input is a string representing a mathematical expression, and the output is an array containing all unique results."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'Input: "2-1-1"\nOutput: [0, 2]\n'})}),"\n",(0,r.jsx)(e.p,{children:"In this example, there are two ways to add parentheses: ((2-1)-1) = 0 and (2-(1-1)) = 2."}),"\n",(0,r.jsx)(e.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,r.jsx)(e.p,{children:"Using the divide-and-conquer approach, we can break down the problem by considering each operator, first solving the sub-expressions on both sides of the operator, and then combining the results using the operator. Special attention is needed for the base case where the input string contains no operators, only a single number."}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)(i,{value:"cpp",label:"C++",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"vector<int> diffWaysToCompute(string expression) {\n    vector<int> ways;\n    unordered_map<char, function<int(int, int)>> op_funcs;\n    op_funcs[\u2019+\u2019] = [](int x, int y) { return x + y; };\n    op_funcs[\u2019-\u2019] = [](int x, int y) { return x - y; };\n    op_funcs[\u2019*\u2019] = [](int x, int y) { return x * y; };\n    for (int i = 0; i < expression.length(); ++i) {\n        char c = expression[i];\n        if (!op_funcs.contains(c)) {\n            continue;\n        }\n        auto left = diffWaysToCompute(expression.substr(0, i));\n        auto right = diffWaysToCompute(expression.substr(i + 1));\n        for (int l : left) {\n            for (int r : right) {\n                ways.push_back(op_funcs[c](l, r));\n            }\n        }\n    }\n    return ways.empty() ? vector<int>{stoi(expression)} : ways;\n}\n"})})}),(0,r.jsx)(i,{value:"py",label:"Python",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-py",children:'def diffWaysToCompute(expression: str) -> List[int]:\n    ways = []\n    op_funcs = {\n        "+": (lambda x, y: x + y),\n        "-": (lambda x, y: x - y),\n        "*": (lambda x, y: x * y),\n    }\n    for i, c in enumerate(expression):\n        if c not in op_funcs:\n            continue\n        left = diffWaysToCompute(expression[:i])\n        right = diffWaysToCompute(expression[i + 1 :])\n        ways += [op_funcs[c](l, r) for l in left for r in right]\n    return [int(expression)] if len(ways) == 0 else ways\n'})})})]}),"\n",(0,r.jsxs)(e.p,{children:["We observe that some substrings produced by the ",(0,r.jsx)(e.code,{children:"divide"})," step may appear multiple times. To avoid redundant calculations, we can use ",(0,r.jsx)(e.code,{children:"memoization"}),". For instance, we can create a hash table where the ",(0,r.jsx)(e.code,{children:"key"})," is ",(0,r.jsx)(e.code,{children:"(l, r)"})," and the ",(0,r.jsx)(e.code,{children:"value"})," is ",(0,r.jsx)(e.code,{children:"ways"}),". Whenever the same ",(0,r.jsx)(e.code,{children:"(l, r)"})," appears again, we can directly return the previously computed ",(0,r.jsx)(e.code,{children:"ways"}),". Alternatively, instead of using a top-down divide-and-conquer approach with ",(0,r.jsx)(e.code,{children:"memoization"}),", we could adopt a bottom-up dynamic programming approach."]}),"\n",(0,r.jsxs)(s,{children:[(0,r.jsx)(i,{value:"cpp",label:"C++",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"vector<int> diffWaysToCompute(string expression) {\n    // Use istringstream to split numbers and operators.\n    vector<int> nums;\n    vector<char> ops;\n    int num = 0;\n    char op = \u2019 \u2019;\n    istringstream ss(expression);\n    while (ss >> num) {\n        nums.push_back(num);\n        if (ss >> op) {\n            ops.push_back(op);\n        }\n    }\n    int n = nums.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>()));\n    unordered_map<char, function<int(int, int)>> op_funcs;\n    op_funcs[\u2019+\u2019] = [](int a, int b) { return a + b; };\n    op_funcs[\u2019-\u2019] = [](int a, int b) { return a - b; };\n    op_funcs[\u2019*\u2019] = [](int a, int b) { return a * b; };\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j >= 0; --j) {\n            if (i == j) {\n                dp[j][i].push_back(nums[i]);\n                continue;\n            }\n            for (int k = j; k < i; ++k) {\n                for (auto l : dp[j][k]) {\n                    for (auto r : dp[k + 1][i]) {\n                        dp[j][i].push_back(op_funcs[ops[k]](l, r));\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n"})})}),(0,r.jsx)(i,{value:"py",label:"Python",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-py",children:'def diffWaysToCompute(expression: str) -> List[int]:\n    # re.split can directly separate operators (\\D) and numbers.\n    sections = re.split(r"(\\D)", expression)\n    nums = [int(num) for num in sections if num.isdigit()]\n    ops = [op for op in sections if not op.isdigit()]\n    n = len(nums)\n    dp = [[[] for _ in range(n)] for _ in range(n)]\n    op_funcs = {\n        "+": (lambda x, y: x + y),\n        "-": (lambda x, y: x - y),\n        "*": (lambda x, y: x * y),\n    }\n    for i in range(n):\n        for j in range(i, -1, -1):\n            if i == j:\n                dp[j][i].append(nums[i])\n                continue\n            for k in range(j, i):\n                dp[j][i] += [op_funcs[ops[k]](l, r)\n                            for l in dp[j][k] for r in dp[k + 1][i]]\n\n    return dp[0][n - 1]\n             \n'})})})]})]})}function l(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}function u(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);