"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[4991],{2482:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"string-manipulation/11-4-string-matching","title":"11.4 String Matching","description":"28. Implement strStr()","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/11-string-manipulation/11-4-string-matching.mdx","sourceDirName":"11-string-manipulation","slug":"/string-manipulation/11-4-string-matching","permalink":"/leetcode_101/en/string-manipulation/11-4-string-matching","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/11-string-manipulation/11-4-string-matching.mdx","tags":[],"version":"current","sidebarPosition":62,"frontMatter":{"sidebar_position":62},"sidebar":"tutorialSidebar","previous":{"title":"11.3 String Parsing","permalink":"/leetcode_101/en/string-manipulation/11-3-string-interpretation"},"next":{"title":"11.5 Exercises","permalink":"/leetcode_101/en/string-manipulation/11-5-exercises"}}');var s=t(4848),a=t(8453);const r={sidebar_position:62},l="11.4 String Matching",c={},o=[{value:"28. Implement strStr()",id:"28-implement-strstr",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3}];function d(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,a.R)(),...e.components},{TabItem:t,Tabs:i}=n;return t||m("TabItem",!0),i||m("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"114-string-matching",children:"11.4 String Matching"})}),"\n",(0,s.jsx)(n.h2,{id:"28-implement-strstr",children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/",children:"28. Implement strStr()"})}),"\n",(0,s.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,s.jsx)(n.p,{children:"Determine whether a string is a substring of another string, and return its starting index."}),"\n",(0,s.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,s.jsx)(n.p,{children:"Input a parent string and a substring, and output an integer representing the position of the substring in the parent string. Return -1 if it doesn't exist."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Input: haystack = "hello", needle = "ll"\nOutput: 2\n'})}),"\n",(0,s.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,s.jsxs)(n.p,{children:["We can use the famous Knuth-Morris-Pratt (KMP) algorithm to achieve matching in ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"O"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mi,{children:"m"}),(0,s.jsx)(n.mo,{children:"+"}),(0,s.jsx)(n.mi,{children:"n"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(m + n)"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"m"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"+"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})]})]})," time using dynamic programming. Here we define the ",(0,s.jsx)(n.code,{children:"dp"})," array where ",(0,s.jsx)(n.code,{children:"dp[i]"})," represents the longest prefix of ",(0,s.jsx)(n.code,{children:"needle"})," that is also a suffix ending at position ",(0,s.jsx)(n.code,{children:"i"}),". For example, for ",(0,s.jsx)(n.code,{children:'needle = "ababaca"'}),", the ",(0,s.jsx)(n.code,{children:"dp"})," array is ",(0,s.jsx)(n.code,{children:"[-1, -1, 0, 1, 2, -1, 0]"}),', indicating the longest matches: [None, None, "a", "ab", "aba", None, "a"].']}),"\n",(0,s.jsx)(n.p,{children:"This problem is complex, and beginners may skip it temporarily."}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)(t,{value:"cpp",label:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Auxiliary function\nvector<int> computeDp(const string &needle) {\n    int n = needle.length();\n    vector<int> dp(n, -1);\n    for (int j = 1, k = -1; j < n; ++j) {\n        while (k > -1 && needle[k + 1] != needle[j]) {\n            k = dp[k];  // If mismatch, backtrack to the previous prefix\n        }\n        if (needle[k + 1] == needle[j]) {\n            ++k;  // Match found, increase the match length\n        }\n        dp[j] = k;  // Update the prefix match position\n    }\n    return dp;\n}\n// Main function\nint strStr(const string &haystack, const string &needle) {\n    int m = haystack.length(), n = needle.length();\n    vector<int> dp = computeDp(needle);\n    for (int i = 0, k = -1; i < m; ++i) {\n        while (k > -1 && needle[k + 1] != haystack[i]) {\n            k = dp[k];  // If mismatch, backtrack to the previous match\n        }\n        if (needle[k + 1] == haystack[i]) {\n            ++k;  / Match found, increase the match length\n        }\n        if (k == n - 1) {\n            return i - n + 1;  // Match complete\n        }\n    }\n    return -1;\n}\n"})})}),(0,s.jsx)(t,{value:"py",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"from typing import List\n\n# Auxiliary function\ndef computeDp(needle: str) -> List[int]:\n    n = len(needle)\n    dp = [-1] * n\n    k = -1\n    for j in range(1, n):\n        while k > -1 and needle[k + 1] != needle[j]:\n            k = dp[k]  # If mismatch, backtrack to the previous prefix\n        if needle[k + 1] == needle[j]:\n            k += 1  # Match found, increase the match length\n        dp[j] = k  # Update the prefix match position\n    return dp\n\n# Main function\ndef strStr(haystack: str, needle: str) -> int:\n    m, n = len(haystack), len(needle)\n    if n == 0:\n        return 0  # Edge case for an empty needle\n    \n    dp = computeDp(needle)\n    k = -1\n    for i in range(m):\n        while k > -1 and needle[k + 1] != haystack[i]:\n            k = dp[k]  # If mismatch, backtrack to the previous match\n        if needle[k + 1] == haystack[i]:\n            k += 1  # Match found, increase the match length\n        if k == n - 1:\n            return i - n + 1  # Match complete\n    return -1\n\n"})})})]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);