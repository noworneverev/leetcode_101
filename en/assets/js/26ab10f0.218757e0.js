"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[2651],{5798:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"dynamic-programming/6-4-partition-problems","title":"6.4 Partition Type Problems","description":"279. Perfect Squares","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/6-dynamic-programming/6-4-partition-problems.mdx","sourceDirName":"6-dynamic-programming","slug":"/dynamic-programming/6-4-partition-problems","permalink":"/leetcode_101/en/dynamic-programming/6-4-partition-problems","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/6-dynamic-programming/6-4-partition-problems.mdx","tags":[],"version":"current","sidebarPosition":29,"frontMatter":{"sidebar_position":29},"sidebar":"tutorialSidebar","previous":{"title":"6.3 Basic Dynamic Programming: Two-Dimensional","permalink":"/leetcode_101/en/dynamic-programming/6-3-basic-dp-2d"},"next":{"title":"6.5 Subsequence Problem","permalink":"/leetcode_101/en/dynamic-programming/6-5-subsequence-problems"}}');var t=i(4848),a=i(8453);const r={sidebar_position:29},l="6.4 Partition Type Problems",o={},d=[{value:"279. Perfect Squares",id:"279-perfect-squares",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"91. Decode Ways",id:"91-decode-ways",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"139. Word Break",id:"139-word-break",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3},{value:"1105. Filling Bookcase Shelves",id:"1105-filling-bookcase-shelves",level:2},{value:"Problem Description",id:"problem-description-3",level:3},{value:"Input and Output Example",id:"input-and-output-example-3",level:3},{value:"Solution Explanation",id:"solution-explanation-3",level:3},{value:"377. Combination Sum IV",id:"377-combination-sum-iv",level:2},{value:"Problem Description",id:"problem-description-4",level:3},{value:"Input and Output Example",id:"input-and-output-example-4",level:3},{value:"Solution Explanation",id:"solution-explanation-4",level:3}];function c(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,a.R)(),...e.components},{TabItem:i,Tabs:s}=n;return i||m("TabItem",!0),s||m("Tabs",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"64-partition-type-problems",children:"6.4 Partition Type Problems"})}),"\n",(0,t.jsx)(n.h2,{id:"279-perfect-squares",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/perfect-squares/",children:"279. Perfect Squares"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Given a positive integer, find the minimum number of perfect square numbers that sum up to the given number."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.p,{children:"The input is a given positive integer, and the output is also a positive integer, representing the minimum number of perfect square numbers that sum up to the input number."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Input: n = 13\nOutput: 2\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this example, the minimal representation of 13 is 4 + 9."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["For partition-type problems, the dynamic programming state transition equation usually does not depend on adjacent positions but on positions that satisfy the partition condition. We define a 1D array ",(0,t.jsx)(n.code,{children:"dp"}),", where ",(0,t.jsx)(n.code,{children:"dp[i]"})," represents the minimum number of perfect square numbers that sum up to ",(0,t.jsx)(n.code,{children:"i"}),". In this problem, position ",(0,t.jsx)(n.code,{children:"i"})," only depends on positions like ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"i"}),(0,t.jsx)(n.mo,{children:"\u2212"}),(0,t.jsxs)(n.msup,{children:[(0,t.jsx)(n.mi,{children:"j"}),(0,t.jsx)(n.mn,{children:"2"})]})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"i - j^2"})]})})}),(0,t.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.7429em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1.0085em",verticalAlign:"-0.1944em"}}),(0,t.jsxs)(n.span,{className:"mord",children:[(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05724em"},children:"j"}),(0,t.jsx)(n.span,{className:"msupsub",children:(0,t.jsx)(n.span,{className:"vlist-t",children:(0,t.jsx)(n.span,{className:"vlist-r",children:(0,t.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,t.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]})]})]})]}),", such as ",(0,t.jsx)(n.code,{children:"i - 1"}),", ",(0,t.jsx)(n.code,{children:"i - 4"}),", ",(0,t.jsx)(n.code,{children:"i - 9"}),", and so on, to meet the perfect square partition condition. Therefore, ",(0,t.jsx)(n.code,{children:"dp[i]"})," can take the minimum value as ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mn,{children:"1"}),(0,t.jsx)(n.mo,{children:"+"}),(0,t.jsx)(n.mi,{children:"min"}),(0,t.jsx)(n.mo,{children:"\u2061"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"d"}),(0,t.jsx)(n.mi,{children:"p"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"["}),(0,t.jsx)(n.mi,{children:"i"}),(0,t.jsx)(n.mo,{children:"\u2212"}),(0,t.jsx)(n.mn,{children:"1"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"]"}),(0,t.jsx)(n.mo,{separator:"true",children:","}),(0,t.jsx)(n.mi,{children:"d"}),(0,t.jsx)(n.mi,{children:"p"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"["}),(0,t.jsx)(n.mi,{children:"i"}),(0,t.jsx)(n.mo,{children:"\u2212"}),(0,t.jsx)(n.mn,{children:"4"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"]"}),(0,t.jsx)(n.mo,{separator:"true",children:","}),(0,t.jsx)(n.mi,{children:"d"}),(0,t.jsx)(n.mi,{children:"p"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"["}),(0,t.jsx)(n.mi,{children:"i"}),(0,t.jsx)(n.mo,{children:"\u2212"}),(0,t.jsx)(n.mn,{children:"9"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"]"}),(0,t.jsx)(n.mo,{separator:"true",children:"\u22c5"}),(0,t.jsx)(n.mo,{separator:"true",children:"\u22c5"}),(0,t.jsx)(n.mo,{separator:"true",children:"\u22c5"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"1 + \\min(dp[i-1], dp[i-4], dp[i-9] \xb7 \xb7 \xb7 )"})]})})}),(0,t.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(n.span,{className:"mord",children:"1"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"+"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mop",children:"min"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"d"}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"}),(0,t.jsx)(n.span,{className:"mopen",children:"["}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord",children:"1"}),(0,t.jsx)(n.span,{className:"mclose",children:"]"}),(0,t.jsx)(n.span,{className:"mpunct",children:","}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"d"}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"}),(0,t.jsx)(n.span,{className:"mopen",children:"["}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord",children:"4"}),(0,t.jsx)(n.span,{className:"mclose",children:"]"}),(0,t.jsx)(n.span,{className:"mpunct",children:","}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"d"}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"p"}),(0,t.jsx)(n.span,{className:"mopen",children:"["}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord",children:"9"}),(0,t.jsx)(n.span,{className:"mclose",children:"]"}),(0,t.jsx)(n.span,{className:"mpunct",children:"\u22c5\u22c5\u22c5"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})]})]}),". Note the handling of boundary conditions."]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)(i,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int numSquares(int n) {\n    vector<int> dp(n + 1, numeric_limits<int>::max());\n    dp[0] = 0;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j * j <= i; ++j) {\n            dp[i] = min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    return dp[n];\n}\n"})})}),(0,t.jsx)(i,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def numSquares(n: int) -> int:\n    dp = [0] + [sys.maxsize] * n\n    for i in range(1, n + 1):\n        for j in range(1, int(floor(sqrt(i))) + 1):\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n    return dp[n]\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"91-decode-ways",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/decode-ways/",children:"91. Decode Ways"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Given that letters A-Z can be represented as numbers 1-26, find the number of ways a given numeric string can be decoded into valid strings."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.p,{children:"The input is a numeric string, and the output is the total number of decoding ways that satisfy the conditions."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Input: "226"\nOutput: 3\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this example, there are three decoding ways: BZ(2 26), VF(22 6), or BBF(2 2 6)."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["This is a classic dynamic programming problem. While not difficult, it requires careful handling of edge cases. Only numbers 1-26 can represent letters, so special conditions such as ",(0,t.jsx)(n.code,{children:"0"})," or adjacent numbers greater than 26 require different state transition formulas, as shown in the code below."]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)(i,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int numDecodings(string s) {\n    int n = s.length();\n    int prev = s[0] - '0';\n    if (prev == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    vector<int> dp(n + 1, 1);\n    for (int i = 2; i <= n; ++i) {\n        int cur = s[i - 1] - '0';\n        if ((prev == 0 || prev > 2) && cur == 0) {\n            // 00, 30, 40, ..., 90 are invalid combinations.\n            return 0;\n        }\n        if ((prev < 2 && prev > 0) || (prev == 2 && cur <= 6)) {\n            // 10, 11, ..., 25, 26.\n            if (cur == 0) {\n                // 10, 20 can only be decoded as two-digit numbers.\n                dp[i] = dp[i - 2];\n            } else {\n                // Can be decoded as a single-digit or two-digit number.\n                dp[i] = dp[i - 2] + dp[i - 1];\n            }\n        } else {\n            // Valid, but can only be decoded as a single-digit number.\n            dp[i] = dp[i - 1];\n        }\n        prev = cur;\n    }\n    return dp[n];\n}\n"})})}),(0,t.jsx)(i,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'def numDecodings(s: str) -> int:\n    n = len(s)\n    prev = ord(s[0]) - ord("0")\n    if prev == 0:\n        return 0\n    if n == 1:\n        return 1\n    dp = [1] * (n + 1)\n    for i in range(2, n + 1):\n        cur = ord(s[i - 1]) - ord("0")\n        if (prev == 0 or prev > 2) and cur == 0:\n            # 00, 30, 40, ..., 90 are invalid combinations.\n            return 0\n        if 0 < prev < 2 or (prev == 2 and cur <= 6):\n            # 10, 11, ..., 25, 26.\n            if cur == 0:\n                # 10, 20 can only be decoded as two-digit numbers.\n                dp[i] = dp[i - 2]\n            else:\n                # Can be decoded as a single-digit or two-digit number.\n                dp[i] = dp[i - 2] + dp[i - 1]\n        else:\n            # Valid, but can only be decoded as a single-digit number.\n            dp[i] = dp[i - 1]\n        prev = cur\n    return dp[n]\n'})})})]}),"\n",(0,t.jsx)(n.h2,{id:"139-word-break",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/word-break/",children:"139. Word Break"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Given a string and a set of strings, determine if there is a way to split the string such that every substring after splitting can be found in the set."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Input: s = "applepenapple", wordDict = ["apple", "pen"]\nOutput: true\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this example, the string can be split into [\u201capple\u201d,\u201cpen\u201d,\u201capple\u201d]."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,t.jsx)(n.p,{children:"Similar to the problem of splitting into perfect squares, the splitting condition in this problem is determined by the strings in the set. When considering each splitting position, we need to iterate through the set of strings to check if the current position can be successfully split. Note that for position 0, the value needs to be initialized to true."}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)(i,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"bool wordBreak(string s, vector<string>& wordDict) {\n    int n = s.length();\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;\n    for (int i = 1; i <= n; ++i) {\n        for (const string& word : wordDict) {\n            int m = word.length();\n            if (i >= m && s.substr(i - m, m) == word) {\n                dp[i] = dp[i - m];\n            }\n            // Early pruning to slightly speed up.\n            // Without pruning, the above line should be dp[i] = dp[i] || dp[i - m];\n            if (dp[i]) {\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n"})})}),(0,t.jsx)(i,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def wordBreak(s: str, wordDict: List[str]) -> bool:\n    n = len(s)\n    dp = [True] + [False] * n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if i >= m and s[i - m : i] == word:\n                dp[i] = dp[i - m]\n            # Early pruning to slightly speed up.\n            # Without pruning, the above line should be dp[i] = dp[i] or dp[i-m]\n            if dp[i]:\n                break\n    return dp[n]\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"1105-filling-bookcase-shelves",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/filling-bookcase-shelves/",children:"1105. Filling Bookcase Shelves"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-3",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Given an array, where each element represents the width and height of a book, determine the minimum total height of a bookshelf with fixed width, where books are placed in the given order from left to right and top to bottom."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-3",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelfWidth = 4\nOutput: 6\n"})}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("span",{style:{display:"block",width:"25%",margin:"0 auto"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://assets.leetcode.com/uploads/2019/06/24/shelves.png",alt:""})})}),(0,t.jsx)("figcaption",{style:{textAlign:"center"},children:"Figure 6.2: Bookcase Arrangement Problem - Example Illustration"})]}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-3",children:"Solution Explanation"}),"\n",(0,t.jsx)(n.p,{children:"Let dp[i] represent the minimum total height when placing the i-th book. dp[i] can either represent placing the i-th book on a new row or on the previous row, provided the row width constraint is satisfied."}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)(i,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {\n    int n = books.size();\n    vector<int> dp(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        int w = books[i - 1][0], h = books[i - 1][1];\n        dp[i] = dp[i - 1] + h;\n        for (int j = i - 1; j > 0; --j) {\n            int prev_w = books[j - 1][0], prev_h = books[j - 1][1];\n            w += prev_w;\n            if (w > shelfWidth) {\n                break;\n            }\n            h = max(h, prev_h);\n            dp[i] = min(dp[i], dp[j - 1] + h);\n        }\n    }\n    return dp[n];\n}\n"})})}),(0,t.jsx)(i,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def minHeightShelves(books: List[List[int]], shelfWidth: int) -> int:\n    n = len(books)\n    dp = [0] * (n + 1)\n    for i, (w, h) in enumerate(books, 1):\n        dp[i] = dp[i - 1] + h\n        for j in range(i - 1, 0, -1):\n            prev_w, prev_h = books[j - 1]\n            w += prev_w\n            if w > shelfWidth:\n                break\n            h = max(h, prev_h)\n            dp[i] = min(dp[i], dp[j - 1] + h)\n    return dp[n]\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"377-combination-sum-iv",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/combination-sum-iv/",children:"377. Combination Sum IV"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-4",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:'Given an array of unique numbers and a target number, find the total number of permutations that sum up to the target. (Although the problem is named "Combination Sum," different orderings of the same combination are considered distinct, so this is essentially a permutation problem.)'}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-4",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Input: nums = [1,2,3], target = 4\nOutput: 7\n"})}),"\n",(0,t.jsx)(n.p,{children:"The seven different permutations are (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), and (3, 1)."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-4",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["Let dp[i] represent the number of permutations that sum up to i. In the inner loop, we directly consider all valid numbers from the array. Note that in the C++ solution, since summing can easily exceed the ",(0,t.jsx)(n.code,{children:"int"})," limit, we use ",(0,t.jsx)(n.code,{children:"double"})," to store the dp array."]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)(i,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int combinationSum4(vector<int>& nums, int target) {\n    vector<double> dp(target + 1, 0);\n    dp[0] = 1;\n    for (int i = 1; i <= target; ++i) {\n        for (int num : nums) {\n            if (num <= i) {\n                dp[i] += dp[i - num];\n            }\n        }\n    }\n    return dp[target];\n}\n"})})}),(0,t.jsx)(i,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def combinationSum4(nums: List[int], target: int) -> int:\n    dp = [1] + [0] * target\n    for i in range(1, target + 1):\n        dp[i] = sum(dp[i - num] for num in nums if i >= num)\n    return dp[target]\n"})})})]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);