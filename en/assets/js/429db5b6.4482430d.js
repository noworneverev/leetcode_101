"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[6333],{1317:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"dynamic-programming/6-8-stock-trading","title":"6.8 Stock Trading","description":"Stock trading problems can often be solved using dynamic programming. For more complex stock trading scenarios, such as requiring cooldown periods or transaction fees, a state machine implemented with dynamic programming is a common approach.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/6-dynamic-programming/6-8-stock-trading.mdx","sourceDirName":"6-dynamic-programming","slug":"/dynamic-programming/6-8-stock-trading","permalink":"/leetcode_101/en/dynamic-programming/6-8-stock-trading","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":33,"frontMatter":{"sidebar_position":33},"sidebar":"tutorialSidebar","previous":{"title":"6.7 String Editing","permalink":"/leetcode_101/en/dynamic-programming/6-7-string-editing"},"next":{"title":"6.9 Exercises","permalink":"/leetcode_101/en/dynamic-programming/6-9-exercises"}}');var t=i(4848),a=i(8453);const l={sidebar_position:33},r="6.8 Stock Trading",o={},c=[{value:"121. Best Time to Buy and Sell Stock",id:"121-best-time-to-buy-and-sell-stock",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"188. Best Time to Buy and Sell Stock IV",id:"188-best-time-to-buy-and-sell-stock-iv",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"309. Best Time to Buy and Sell Stock with Cooldown",id:"309-best-time-to-buy-and-sell-stock-with-cooldown",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3}];function d(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",math:"math",mi:"mi",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",...(0,a.R)(),...e.components},{TabItem:s,Tabs:l}=n;return s||m("TabItem",!0),l||m("Tabs",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"68-stock-trading",children:"6.8 Stock Trading"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Stock trading"})," problems can often be solved using dynamic programming. For more complex stock trading scenarios, such as requiring cooldown periods or transaction fees, a ",(0,t.jsx)(n.code,{children:"state machine"})," implemented with dynamic programming is a common approach."]}),"\n",(0,t.jsx)(n.h2,{id:"121-best-time-to-buy-and-sell-stock",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",children:"121. Best Time to Buy and Sell Stock"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Given the fixed prices of a stock over a period of days, where you can only buy and sell once, find the maximum profit."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.p,{children:"The input is a one-dimensional array of integers representing daily stock prices, and the output is an integer representing the maximum profit."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Input: [7,1,5,3,6,4]\nOutput: 5\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this example, the maximum profit is achieved by buying on day 2 (price = 1) and selling on day 5 (price = 6)."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["We can traverse the array once, maintaining a record of the lowest price encountered before each day ",(0,t.jsx)(n.code,{children:"i"}),". For each price, calculate the profit as the difference between the current price and the minimum price seen so far. Update the maximum profit accordingly. Note that in this problem, as well as others, ",(0,t.jsx)(n.code,{children:"buy"})," and ",(0,t.jsx)(n.code,{children:"sell"})," represent account operations: buying decreases account value (negative), and selling increases it (positive)."]}),"\n",(0,t.jsxs)(l,{children:[(0,t.jsx)(s,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int maxProfit(vector<int>& prices) {\n    int buy = numeric_limits<int>::lowest(), sell = 0;\n    for (int price : prices) {\n        buy = max(buy, -price);\n        sell = max(sell, buy + price);\n    }\n    return sell;\n}\n"})})}),(0,t.jsx)(s,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def maxProfit(prices: List[int]) -> int:\n    buy, sell = -sys.maxsize, 0\n    for price in prices:\n        buy = max(buy, -price)\n        sell = max(sell, buy + price)\n    return sell\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"188-best-time-to-buy-and-sell-stock-iv",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/",children:"188. Best Time to Buy and Sell Stock IV"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,t.jsxs)(n.p,{children:["Given the fixed prices of a stock over a period of days, you can buy and sell at most ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"k"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"k"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"})]})})]})," times, holding at most one stock at a time. Find the maximum profit."]}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,t.jsxs)(n.p,{children:["The input is a one-dimensional array of integers representing daily stock prices, and an integer ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"k"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"k"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"})]})})]})," representing the number of allowed transactions. The output is an integer representing the maximum profit."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Input: [3,2,6,5,0,3], k = 2\nOutput: 7\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this example, the maximum profit is achieved by buying on day 2 (price = 2) and selling on day 3 (price = 6); then buying again on day 5 (price = 0) and selling on day 6 (price = 3)."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["Similarly, we can define two dynamic programming arrays, ",(0,t.jsx)(n.code,{children:"buy"})," and ",(0,t.jsx)(n.code,{children:"sell"}),". For each day, ",(0,t.jsx)(n.code,{children:"buy[j]"})," represents the maximum profit after the ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"j"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"j"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.854em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05724em"},children:"j"})]})})]}),"-th buy, and ",(0,t.jsx)(n.code,{children:"sell[j]"})," represents the maximum profit after the ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"j"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"j"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.854em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05724em"},children:"j"})]})})]}),"-th sell."]}),"\n",(0,t.jsxs)(l,{children:[(0,t.jsx)(s,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int maxProfit(int k, vector<int>& prices) {\n    int days = prices.size();\n    vector<int> buy(k + 1, numeric_limits<int>::lowest()), sell(k + 1, 0);\n    for (int i = 0; i < days; ++i) {\n        for (int j = 1; j <= k; ++j) {\n            buy[j] = max(buy[j], sell[j - 1] - prices[i]);\n            sell[j] = max(sell[j], buy[j] + prices[i]);\n        }\n    }\n    return sell[k];\n}\n"})})}),(0,t.jsx)(s,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def maxProfit(k: int, prices: List[int]) -> int:\n    days = len(prices)\n    buy, sell = [-sys.maxsize] * (k + 1), [0] * (k + 1)\n    for i in range(days):\n        for j in range(1, k + 1):\n            buy[j] = max(buy[j], sell[j - 1] - prices[i])\n            sell[j] = max(sell[j], buy[j] + prices[i])\n    return sell[k]\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"309-best-time-to-buy-and-sell-stock-with-cooldown",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/",children:"309. Best Time to Buy and Sell Stock with Cooldown"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Given the fixed prices of a stock over a period of days, you can only own one stock at a time, and after selling a stock, you must wait one day (cooldown) before buying again. Find the maximum profit."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.p,{children:"The input is a one-dimensional array of integers representing daily stock prices. The output is an integer representing the maximum profit."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Input: [1,2,3,0,2]\nOutput: 3\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this example, the optimal sequence of operations is buy, sell, cooldown, buy, sell."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["We can solve such complex state transition problems using a ",(0,t.jsx)(n.strong,{children:"state machine"}),". By defining multiple states and their transitions, we can derive the transition equations for each state. As illustrated, we can define four states to represent stock transactions with cooldowns, along with their transitions."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("span",{style:{display:"block",width:"40%",margin:"0 auto"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(4993).A+"",width:"552",height:"520"})})}),(0,t.jsx)("figcaption",{style:{textAlign:"center"},children:"Figure 6.5: Problem 309 - State Machine Transitions"})]}),"\n",(0,t.jsxs)(l,{children:[(0,t.jsx)(s,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int maxProfit(vector<int>& prices) {\n    int n = prices.size();\n    vector<int> buy(n), sell(n), s1(n), s2(n);\n    s1[0] = buy[0] = -prices[0];\n    sell[0] = s2[0] = 0;\n    for (int i = 1; i < n; ++i) {\n        buy[i] = s2[i - 1] - prices[i];\n        s1[i] = max(buy[i - 1], s1[i - 1]);\n        sell[i] = max(buy[i - 1], s1[i - 1]) + prices[i];\n        s2[i] = max(s2[i - 1], sell[i - 1]);\n    }\n    return max(sell[n - 1], s2[n - 1]);\n}\n"})})}),(0,t.jsx)(s,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def maxProfit(prices: List[int]) -> int:\n    n = len(prices)\n    buy, sell, s1, s2 = [0] * n, [0] * n, [0] * n, [0] * n\n    s1[0] = buy[0] = -prices[0]\n    sell[0] = s2[0] = 0\n    for i in range(1, n):\n        buy[i] = s2[i - 1] - prices[i]\n        s1[i] = max(buy[i - 1], s1[i - 1])\n        sell[i] = max(buy[i - 1], s1[i - 1]) + prices[i]\n        s2[i] = max(s2[i - 1], sell[i - 1])\n    return max(sell[n - 1], s2[n - 1])\n"})})})]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},4993:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/6.5-91923e38e2992faf249854d49cd28aa0.png"}}]);