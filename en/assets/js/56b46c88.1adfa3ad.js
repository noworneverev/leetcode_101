"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[2189],{4960:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"dynamic-programming/6-5-subsequence-problems","title":"6.5 Subsequence Problem","description":"300. Longest Increasing Subsequence","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/6-dynamic-programming/6-5-subsequence-problems.mdx","sourceDirName":"6-dynamic-programming","slug":"/dynamic-programming/6-5-subsequence-problems","permalink":"/leetcode_101/en/dynamic-programming/6-5-subsequence-problems","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/6-dynamic-programming/6-5-subsequence-problems.mdx","tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"sidebar_position":30},"sidebar":"tutorialSidebar","previous":{"title":"6.4 Partition Type Problems","permalink":"/leetcode_101/en/dynamic-programming/6-4-partition-problems"},"next":{"title":"6.6 Knapsack Problem","permalink":"/leetcode_101/en/dynamic-programming/6-6-knapsack-problem"}}');var t=s(4848),a=s(8453);const r={sidebar_position:30},l="6.5 Subsequence Problem",o={},c=[{value:"300. Longest Increasing Subsequence",id:"300-longest-increasing-subsequence",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"1143. Longest Commom Subsequence",id:"1143-longest-commom-subsequence",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3}];function d(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,a.R)(),...e.components},{TabItem:s,Tabs:i}=n;return s||m("TabItem",!0),i||m("Tabs",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"65-subsequence-problem",children:"6.5 Subsequence Problem"})}),"\n",(0,t.jsx)(n.h2,{id:"300-longest-increasing-subsequence",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/longest-increasing-subsequence/",children:"300. Longest Increasing Subsequence"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Given an unsorted array of integers, find the length of the longest increasing subsequence."}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsx)(n.p,{children:"According to LeetCode conventions, a subsequence does not need to be contiguous, while a subarray or substring must be contiguous."})}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.p,{children:"Input is a 1D array, and output is a positive integer representing the length of the longest increasing subsequence."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Input: [10,9,2,5,3,7,101,4]\nOutput: 4\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this example, one of the longest increasing subsequences is [2,3,7,101]."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,t.jsx)(n.p,{children:"For subsequence problems, a common dynamic programming approach is to define a dp array where dp[i] represents the property of a subsequence ending at index i. After processing each position, summing up the results of all positions will yield the required result."}),"\n",(0,t.jsxs)(n.p,{children:["In this problem, dp[i] represents the length of the longest subsequence ending at index i. For each position i, if a previous position j has a smaller value than nums[i], we can form a subsequence of length dp[j] + 1 ending at i. To check all possibilities, we use a nested loop with i and j, resulting in a time complexity of ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsxs)(n.msup,{children:[(0,t.jsx)(n.mi,{children:"n"}),(0,t.jsx)(n.mn,{children:"2"})]}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n^2)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsxs)(n.span,{className:"mord",children:[(0,t.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(n.span,{className:"msupsub",children:(0,t.jsx)(n.span,{className:"vlist-t",children:(0,t.jsx)(n.span,{className:"vlist-r",children:(0,t.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,t.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]}),"."]}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)(s,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int lengthOfLIS(vector<int>& nums) {\n    int max_len = 0, n = nums.size();\n    vector<int> dp(n, 1);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        max_len = max(max_len, dp[i]);\n    }\n    return max_len;\n}\n"})})}),(0,t.jsx)(s,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def lengthOfLIS(nums: List[int]) -> int:\n    n = len(nums)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n"})})})]}),"\n",(0,t.jsxs)(n.p,{children:["This problem can also be solved using binary search to reduce the time complexity to ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"n"}),(0,t.jsx)(n.mi,{children:"log"}),(0,t.jsx)(n.mo,{children:"\u2061"}),(0,t.jsx)(n.mi,{children:"n"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(n \\log n)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsxs)(n.span,{className:"mop",children:["lo",(0,t.jsx)(n.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]}),". We define a ",(0,t.jsx)(n.code,{children:"dp"})," array where ",(0,t.jsx)(n.code,{children:"dp[k]"})," stores the last number of the longest increasing subsequence of length ",(0,t.jsx)(n.code,{children:"k+1"}),". As we iterate through each position ",(0,t.jsx)(n.code,{children:"i"}),", if the number is larger than all numbers in the ",(0,t.jsx)(n.code,{children:"dp"})," array, we append it to the end of ",(0,t.jsx)(n.code,{children:"dp"}),", indicating that the length of the longest increasing subsequence has increased by 1. If the number lies between two numbers ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," in the ",(0,t.jsx)(n.code,{children:"dp"})," array, we replace ",(0,t.jsx)(n.code,{children:"b"})," with this number to increase the possibility of forming a longer increasing subsequence. Using this method, the ",(0,t.jsx)(n.code,{children:"dp"})," array is always maintained in increasing order, allowing us to use binary search to speed up the process."]}),"\n",(0,t.jsx)(n.p,{children:"For example, for the array [10,9,2,5,3,7,101,4], the updates in each round are as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"num    dp\n10     [10]\n9      [9]\n2      [2]\n5      [2,5]\n3      [2,3]\n7      [2,3,7]\n101    [2,3,7,101]\n4      [2,3,4,101]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Finally, we determine that the length of the longest increasing subsequence is 4. Note that the final form of the ",(0,t.jsx)(n.code,{children:"dp"})," array does not necessarily represent a valid subsequence, e.g., [2,3,4,101] is not a subsequence, but the previously updated [2,3,7,101] is one of the optimal solutions."]}),"\n",(0,t.jsx)(n.p,{children:"Similarly, for other problems, if the results of the state transition equation are increasing or decreasing and require insertion or search operations, we can also use binary search to speed up the solution."}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)(s,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int lengthOfLIS(vector<int>& nums) {\n    vector<int> dp{nums[0]};\n    for (int num : nums) {\n        if (dp.back() < num) {\n            dp.push_back(num);\n        } else {\n            *lower_bound(dp.begin(), dp.end(), num) = num;\n        }\n    }\n    return dp.size();\n}\n"})})}),(0,t.jsx)(s,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def lengthOfLIS(nums: List[int]) -> int:\n    dp = [nums[0]]\n    for num in nums:\n        if dp[-1] < num:\n            dp.append(num)\n        else:\n            dp[bisect.bisect_left(dp, num, 0, len(dp))] = num\n    return len(dp)\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"1143-longest-commom-subsequence",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/longest-common-subsequence/",children:"1143. Longest Commom Subsequence"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Given two strings, find the length of their longest common subsequence."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.p,{children:"Input consists of two strings, and the output is an integer representing the length of their longest common subsequence."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Input: text1 = "abcde", text2 = "ace"\nOutput: 3\n'})}),"\n",(0,t.jsx)(n.p,{children:'In this example, the longest common subsequence is "ace."'}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,t.jsx)(n.p,{children:"For subsequence problems, the second dynamic programming approach defines a dp array where dp[i] represents the property of the subsequence up to position i, without requiring it to end at i. The final result is the last value of the dp array, eliminating the need to compute each position."}),"\n",(0,t.jsx)(n.p,{children:"In this problem, we use a 2D array dp, where dp[i][j] represents the length of the longest common subsequence up to position i in the first string and position j in the second string. This makes it straightforward to handle the cases where the letters at these positions are the same or different."}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)(s,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int longestCommonSubsequence(string text1, string text2) {\n    int m = text1.length(), n = text2.length();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (text1[i - 1] == text2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n"})})}),(0,t.jsx)(s,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n"})})})]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}function m(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);