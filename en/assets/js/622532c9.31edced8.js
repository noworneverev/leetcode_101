"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[5555],{1523:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"trees/13-1-data-structure-introduction","title":"13.1 Data Structure Introduction","description":"As an upgraded version of the (single) linked list, the trees we commonly encounter are typically binary trees, where each node has at most two child nodes. Unless otherwise specified, trees are assumed to have no circular structures. LeetCode\'s default representation of trees is as follows:","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/13-trees/13-1-data-structure-introduction.mdx","sourceDirName":"13-trees","slug":"/trees/13-1-data-structure-introduction","permalink":"/leetcode_101/en/trees/13-1-data-structure-introduction","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":68,"frontMatter":{"sidebar_position":68},"sidebar":"tutorialSidebar","previous":{"title":"13. \u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e8c\uff1a\u6811","permalink":"/leetcode_101/en/category/13-\u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e8c\u6811"},"next":{"title":"13.2 Tree Recursion","permalink":"/leetcode_101/en/trees/13-2-tree-recursion"}}');var s=r(4848),o=r(8453);const i={sidebar_position:68},a="13.1 Data Structure Introduction",c={},d=[];function l(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components},{TabItem:r,Tabs:n}=t;return r||h("TabItem",!0),n||h("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"131-data-structure-introduction",children:"13.1 Data Structure Introduction"})}),"\n",(0,s.jsxs)(t.p,{children:["As an upgraded version of the (single) linked list, the trees we commonly encounter are typically ",(0,s.jsx)(t.code,{children:"binary trees"}),", where each node has at most two child nodes. Unless otherwise specified, trees are assumed to have no circular structures. LeetCode's default representation of trees is as follows:"]}),"\n",(0,s.jsxs)(n,{children:[(0,s.jsx)(r,{value:"cpp",label:"C++",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"struct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n"})})}),(0,s.jsx)(r,{value:"py",label:"Python",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-py",children:"class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n"})})})]}),"\n",(0,s.jsx)(t.p,{children:"It can be seen that the primary difference compared to a linked list is the addition of a pointer for a second child node."})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}function h(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);