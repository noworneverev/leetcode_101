"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[9331],{14:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"advanced-data-structures/15-3-composite-data-structures","title":"15.3 Composite Data Structures","description":"This type of problem often uses a hash table or ordered map for auxiliary record-keeping to speed up lookups; paired with arrays or linked lists for continuous data storage to expedite sequential selection or value deletion.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/15-advanced-data-structures/15-3-composite-data-structures.mdx","sourceDirName":"15-advanced-data-structures","slug":"/advanced-data-structures/15-3-composite-data-structures","permalink":"/leetcode_101/en/advanced-data-structures/15-3-composite-data-structures","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":77,"frontMatter":{"sidebar_position":77},"sidebar":"tutorialSidebar","previous":{"title":"15.2 Union-Find","permalink":"/leetcode_101/en/advanced-data-structures/15-2-union-find"},"next":{"title":"15.4 Exercises","permalink":"/leetcode_101/en/advanced-data-structures/15-4-exercises"}}');var s=t(4848),i=t(8453);const l={sidebar_position:77},r="15.3 Composite Data Structures",o={},d=[{value:"146. LRU Cache",id:"146-lru-cache",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"380. Insert Delete GetRandom O(1)",id:"380-insert-delete-getrandom-o1",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3}];function c(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,i.R)(),...e.components},{TabItem:t,Tabs:a}=n;return t||h("TabItem",!0),a||h("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"153-composite-data-structures",children:"15.3 Composite Data Structures"})}),"\n",(0,s.jsx)(n.p,{children:"This type of problem often uses a hash table or ordered map for auxiliary record-keeping to speed up lookups; paired with arrays or linked lists for continuous data storage to expedite sequential selection or value deletion."}),"\n",(0,s.jsx)(n.h2,{id:"146-lru-cache",children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/lru-cache/",children:"146. LRU Cache"})}),"\n",(0,s.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,s.jsx)(n.p,{children:"Design a fixed-size Least Recently Used Cache (LRU). When inserting data into a non-full cache or updating/retrieving existing data in the cache, mark the data as recently used. When the cache is full, evict the least recently used data, insert the new data, and mark it as recently used."}),"\n",(0,s.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,s.jsxs)(n.p,{children:["Here is an example of calling this data structure. Given a cache with size ",(0,s.jsx)(n.code,{children:"n"}),", store data using the least recently used strategy."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"LRUCache cache = new LRUCache( 2 /* capacity */ );\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1); // Output value 1\ncache.put(3, 3); // Evict  key 2\ncache.get(2); // Output value -1 (not found)\ncache.put(4, 4); // Evict  key 1\ncache.get(1); // Output value -1 (not found)\ncache.get(3); // Output value 3\ncache.get(4); // Output value 4\n"})}),"\n",(0,s.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,s.jsx)(n.p,{children:"We use a linked list to store the keys and values, with the order of the linked list representing the least-to-most recently used sequence. The most recently used data resides at the head of the list. Additionally, a hash table is used for lookups, where the key corresponds to the data key and the value points to the corresponding pointer/iterator in the linked list. On every cache hit (successful lookup), the corresponding node is moved to the head of the linked list."}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsx)(t,{value:"cpp",label:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class LRUCache {\n   public:\n    LRUCache(int capacity) : n_(capacity) {}\n\n    int get(int key) {\n        auto it = key_to_cache_it_.find(key);\n        if (it == key_to_cache_it_.end()) {\n            return -1;\n        }\n        cache_.splice(cache_.begin(), cache_, it->second);\n        return it->second->second;\n    }\n\n    void put(int key, int value) {\n        auto it = key_to_cache_it_.find(key);\n        if (it != key_to_cache_it_.end()) {\n            it->second->second = value;\n            return cache_.splice(cache_.begin(), cache_, it->second);\n        }\n        cache_.insert(cache_.begin(), make_pair(key, value));\n        key_to_cache_it_[key] = cache_.begin();\n        if (cache_.size() > n_) {\n            key_to_cache_it_.erase(cache_.back().first);\n            cache_.pop_back();\n        }\n    }\n\n   private:\n    list<pair<int, int>> cache_;\n    unordered_map<int, list<pair<int, int>>::iterator> key_to_cache_it_;\n    int n_;\n};\n"})})}),(0,s.jsx)(t,{value:"py",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"class Node:\n    def __init__(self, key=-1, val=-1):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.dummy_start = Node()\n        self.dummy_end = Node()\n        self.dummy_start.next = self.dummy_end\n        self.dummy_end.prev = self.dummy_start\n\n    def appendleft(self, node) -> Node:\n        left, right = self.dummy_start, self.dummy_start.next\n        node.next = right\n        right.prev = node\n        left.next = node\n        node.prev = left\n        return node\n\n    def remove(self, node) -> Node:\n        left, right = node.prev, node.next\n        left.next = right\n        right.prev = left\n        return node\n\n    def move_to_start(self, node):\n        return self.appendleft(self.remove(node))\n\n    def pop(self):\n        return self.remove(self.dummy_end.prev)\n\n    def peek(self):\n        return self.dummy_end.prev.val\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.n = capacity\n        self.key_to_node = dict()\n        self.cache_nodes = LinkedList()\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_node:\n            return -1\n        node = self.key_to_node[key]\n        self.cache_nodes.move_to_start(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.key_to_node:\n            node = self.cache_nodes.remove(self.key_to_node[key])\n            node.val = value\n        else:\n            node = Node(key, value)\n            self.key_to_node[key] = node\n        self.cache_nodes.appendleft(node)\n        if len(self.key_to_node) > self.n:\n            self.key_to_node.pop(self.cache_nodes.pop().key)\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["In Python, we can directly use the ",(0,s.jsx)(n.code,{children:"OrderedDict"})," function to implement LRU, which significantly simplifies the problem. However, the author encourages readers to carefully study the explanation above to understand the core principles behind LRU implementation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"class LRUCache:\n    def __init__(self, capacity: int):\n        self.n = capacity\n        self.cache = {}\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache[key] = self.cache.pop(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.n:\n            self.cache.pop(next(iter(self.cache)))\n"})}),"\n",(0,s.jsx)(n.h2,{id:"380-insert-delete-getrandom-o1",children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/insert-delete-getrandom-o1/",children:"380. Insert Delete GetRandom O(1)"})}),"\n",(0,s.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,s.jsxs)(n.p,{children:["Design a data structure that supports insertion, deletion, and random access, all in ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mi,{children:"O"}),(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mn,{children:"1"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,s.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord",children:"1"}),(0,s.jsx)(n.span,{className:"mclose",children:")"})]})})]})," time complexity."]}),"\n",(0,s.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,s.jsx)(n.p,{children:"Here is an example of how the data structure is used:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"RandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1);\nrandomizedSet.remove(2);\nrandomizedSet.insert(2);\nrandomizedSet.getRandom(); // 50% 1, 50% 2\nrandomizedSet.remove(1);\nrandomizedSet.insert(2);\nrandomizedSet.getRandom(); // 100% 2\n"})}),"\n",(0,s.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,s.jsx)(n.p,{children:"We use an array to store the inserted numbers and a hash table to track their positions. When inserting a number, we add it directly to the array and record its position in the hash table. When deleting a number, we swap the current last element of the array with the element to be removed and update the hash table. For random access, we can simply select any position in the array."}),"\n",(0,s.jsxs)(a,{children:[(0,s.jsx)(t,{value:"cpp",label:"C++",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class RandomizedSet {\n   public:\n    bool insert(int val) {\n        if (v_to_k_.contains(val)) {\n            return false;\n        }\n        v_to_k_[val] = nums_.size();\n        nums_.push_back(val);\n        return true;\n    }\n\n    bool remove(int val) {\n        if (!v_to_k_.contains(val)) {\n            return false;\n        }\n        v_to_k_[nums_.back()] = v_to_k_[val];\n        nums_[v_to_k_[val]] = nums_.back();\n        v_to_k_.erase(val);\n        nums_.pop_back();\n        return true;\n    }\n\n    int getRandom() { return nums_[rand() % nums_.size()]; }\n\n   private:\n    unordered_map<int, int> v_to_k_;\n    vector<int> nums_;\n};\n"})})}),(0,s.jsx)(t,{value:"py",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"class RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.v_to_k = {}\n\n    def insert(self, val: int) -> bool:\n        if val in self.v_to_k:\n            return False\n        self.v_to_k[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.v_to_k:\n            return False\n        self.v_to_k[self.nums[-1]] = self.v_to_k[val]\n        self.nums[self.v_to_k[val]] = self.nums[-1]\n        del self.v_to_k[val]\n        self.nums.pop()\n        return True\n\n    def getRandom(self) -> int:\n        return self.nums[random.randint(0, len(self.nums) - 1)]\n"})})})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);