"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[7502],{1923:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"advanced-data-structures/15-2-union-find","title":"15.2 Union-Find","description":"Union-Find (disjoint set) is a data structure used for dynamic connectivity problems. It efficiently connects two points and determines whether two points are connected. Given n nodes, we initialize the parent of each node to itself. To connect nodes i and j, we attach the smaller rank\'s parent to the larger rank\'s parent (union by rank). To check if two nodes are connected, we find their ancestors and determine if they are the same, applying path compression to speed up subsequent queries.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/15-advanced-data-structures/15-2-union-find.mdx","sourceDirName":"15-advanced-data-structures","slug":"/advanced-data-structures/15-2-union-find","permalink":"/leetcode_101/en/advanced-data-structures/15-2-union-find","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/15-advanced-data-structures/15-2-union-find.mdx","tags":[],"version":"current","sidebarPosition":76,"frontMatter":{"sidebar_position":76},"sidebar":"tutorialSidebar","previous":{"title":"15.1 Introduction","permalink":"/leetcode_101/en/advanced-data-structures/15-1-introduction"},"next":{"title":"15.3 Composite Data Structures","permalink":"/leetcode_101/en/advanced-data-structures/15-3-composite-data-structures"}}');var d=i(4848),s=i(8453);const r={sidebar_position:76},o="15.2 Union-Find",a={},c=[{value:"684. Redundant Connection",id:"684-redundant-connection",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",...(0,s.R)(),...e.components},{TabItem:t,Tabs:r}=n;return t||u("TabItem",!0),r||u("Tabs",!0),(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"152-union-find",children:"15.2 Union-Find"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Union-Find"})," (disjoint set) is a data structure used for dynamic connectivity problems. It efficiently connects two points and determines whether two points are connected. Given ",(0,d.jsx)(n.code,{children:"n"})," nodes, we initialize the parent of each node to itself. To connect nodes ",(0,d.jsx)(n.code,{children:"i"})," and ",(0,d.jsx)(n.code,{children:"j"}),", we attach the smaller rank's parent to the larger rank's parent (union by rank). To check if two nodes are connected, we find their ancestors and determine if they are the same, applying path compression to speed up subsequent queries."]}),"\n",(0,d.jsxs)("figure",{children:[(0,d.jsx)("span",{style:{display:"block",width:"30%",margin:"0 auto"},children:(0,d.jsx)(n.p,{children:(0,d.jsx)(n.img,{src:i(4390).A+"",width:"206",height:"619"})})}),(0,d.jsxs)("figcaption",{style:{textAlign:"center"},children:["Figure 15.1: Union-Find Example. ",(0,d.jsx)(n.code,{children:"union"})," merges two sets by rank, and ",(0,d.jsx)(n.code,{children:"find"})," retrieves a node's ancestor while compressing paths."]})]}),"\n",(0,d.jsx)(n.h2,{id:"684-redundant-connection",children:(0,d.jsx)(n.a,{href:"https://leetcode.com/problems/redundant-connection/",children:"684. Redundant Connection"})}),"\n",(0,d.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,d.jsx)(n.p,{children:"In an undirected graph, find an edge that, when removed, leaves the graph as a tree (i.e., acyclic and connected). If there are multiple solutions, return the edge appearing last in the input."}),"\n",(0,d.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,d.jsx)(n.p,{children:"The input is a 2D array representing all edges (pairs of nodes), and the output is a 1D array representing the edge to remove."}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"Input: [[1,2], [1,3], [2,3]]\n  1\n / \\\n2 - 3\nOutput: [2,3]\n"})}),"\n",(0,d.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,d.jsx)(n.p,{children:"Since we need to determine whether two nodes are repeatedly connected, we can solve this problem using the Union-Find data structure. The detailed implementation is as follows:"}),"\n",(0,d.jsxs)(r,{children:[(0,d.jsx)(t,{value:"cpp",label:"C++",children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"class Solution {\n   public:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        n_ = edges.size();\n        id_ = vector<int>(n_);\n        depth_ = vector<int>(n_, 1);\n        for (int i = 0; i < n_; ++i) {\n            id_[i] = i;\n        }\n        for (auto& edge : edges) {\n            int i = edge[0], j = edge[1];\n            if (linked(i - 1, j - 1)) {\n                return vector<int>{i, j};\n            }\n            connect(i - 1, j - 1);\n        }\n        return vector<int>();\n    }\n\n   private:\n    int find(int i) {\n        // Path Compression\n        while (i != id_[i]) {\n            id_[i] = id_[id_[i]];\n            i = id_[i];\n        }\n        return i;\n    }\n\n    void connect(int i, int j) {\n        i = find(i), j = find(j);\n        if (i == j) {\n            return;\n        }\n        // Union by Rank\n        if (depth_[i] <= depth_[j]) {\n            id_[i] = j;\n            depth_[j] = max(depth_[j], depth_[i] + 1);\n        } else {\n            id_[j] = i;\n            depth_[i] = max(depth_[i], depth_[j] + 1);\n        }\n    }\n\n    bool linked(int i, int j) { return find(i) == find(j); }\n\n    int n_;\n    vector<int> id_;\n    vector<int> depth_;\n};\n"})})}),(0,d.jsx)(t,{value:"py",label:"Python",children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-py",children:"class Solution:\n    def __init__(self):\n        self.n = 0\n        self.id = None\n        self.depth = None\n\n    def find(self, i: int) -> int:\n        # Path Compression\n        while i != self.id[i]:\n            self.id[i] = self.id[self.id[i]]\n            i = self.id[i]\n        return i\n\n    def connect(self, i: int, j: int):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        # Union by Rank\n        if self.depth[i] <= self.depth[j]:\n            self.id[i] = j\n            self.depth[j] = max(self.depth[j], self.depth[i] + 1)\n        else:\n            self.id[j] = i\n            self.depth[i] = max(self.depth[i], self.depth[j] + 1)\n\n    def linked(self, i: int, j: int) -> bool:\n        return self.find(i) == self.find(j)\n\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        self.n = len(edges)\n        self.id = list(range(self.n))\n        self.depth = [1] * self.n\n        for i, j in edges:\n            if self.linked(i - 1, j - 1):\n                return [i, j]\n            self.connect(i - 1, j - 1)\n        return []\n"})})})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},4390:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/15.1-998289baad97da9d58281ad30dc8523a.png"}}]);