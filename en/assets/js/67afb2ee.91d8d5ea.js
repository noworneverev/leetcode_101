"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[2061],{2834:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"searching-algorithms/5-2-depth-first-search","title":"5.2 Depth First Search","description":"Depth First Search (DFS) is a search method where, upon encountering a new node, you immediately traverse that new node. Therefore, traversal requires a Last In, First Out (LIFO) stack, which can also be implemented using recursion, equivalent to using a stack. In a tree structure, since traversal always invokes the new node, it appears as if progressing in the \\"depth\\" direction. In Python, collections.deque can be used to implement the stack in C++. However, in most cases, using vector in C++ or list in Python is preferred as these structures not only support LIFO but also allow random access.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/5-searching-algorithms/5-2-depth-first-search.mdx","sourceDirName":"5-searching-algorithms","slug":"/searching-algorithms/5-2-depth-first-search","permalink":"/leetcode_101/en/searching-algorithms/5-2-depth-first-search","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/5-searching-algorithms/5-2-depth-first-search.mdx","tags":[],"version":"current","sidebarPosition":22,"frontMatter":{"sidebar_position":22},"sidebar":"tutorialSidebar","previous":{"title":"5.1 Algorithm Explanation","permalink":"/leetcode_101/en/searching-algorithms/5-1-algorithm-explanation"},"next":{"title":"5.3 Backtracking","permalink":"/leetcode_101/en/searching-algorithms/5-3-backtracking"}}');var r=i(4848),a=i(8453);const s={sidebar_position:22},o="5.2 Depth First Search",c={},d=[{value:"695. Max Area of Island",id:"695-max-area-of-island",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"547. Number of Provinces",id:"547-number-of-provinces",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"417. Paci\ufb01c Atlantic Water Flow",id:"417-paci\ufb01c-atlantic-water-flow",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components},{TabItem:i,Tabs:t}=n;return i||p("TabItem",!0),t||p("Tabs",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"52-depth-first-search",children:"5.2 Depth First Search"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Depth First Search (DFS)"})," is a search method where, upon encountering a new node, you immediately traverse that new node. Therefore, traversal requires a ",(0,r.jsx)(n.code,{children:"Last In, First Out (LIFO) stack"}),", which can also be implemented using ",(0,r.jsx)(n.code,{children:"recursion"}),', equivalent to using a stack. In a tree structure, since traversal always invokes the new node, it appears as if progressing in the "depth" direction. In Python, collections.deque can be used to implement the stack in C++. However, in most cases, using vector in C++ or list in Python is preferred as these structures not only support LIFO but also allow random access.']}),"\n",(0,r.jsx)(n.p,{children:'Consider the following simple tree, starting traversal from node 1. If the traversal order is from the left child to the right child, the process follows the strategy of moving "deeper" first: 1 (starting node) \u2192 2 (deeper left child) \u2192 4 (deeper left child) \u2192 2 (no children, return to parent) \u2192 1 (all children traversed, return to parent) \u2192 3 (deeper right child) \u2192 1 (no children, return to parent) \u2192 end (all children traversed). If implemented with a stack, the stack\'s top element evolves as follows: 1 \u2192 2 \u2192 4 \u2192 3.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"   1\n  / \\\n  2 3\n /\n4\n"})}),"\n",(0,r.jsxs)(n.p,{children:["DFS can also be used to ",(0,r.jsx)(n.code,{children:"detect cycles"}),": Record the parent node of each traversed node. If a node is revisited with a different parent, a cycle is detected. Alternatively, topological sorting can identify cycles: if a node has a non-zero in-degree at the end, a cycle exists."]}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes, it is necessary to mark already traversed nodes to avoid redundant searches. This technique is called ",(0,r.jsx)(n.code,{children:"state recording"})," or ",(0,r.jsx)(n.code,{children:"memoization"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"695-max-area-of-island",children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/max-area-of-island/",children:"695. Max Area of Island"})}),"\n",(0,r.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,r.jsxs)(n.p,{children:["Given a 2D binary grid where ",(0,r.jsx)(n.code,{children:"0"})," represents water and ",(0,r.jsx)(n.code,{children:"1"})," represents land, islands are formed by connected land cells. Each cell is connected only to its adjacent cells (up, down, left, right). Find the maximum area of an island."]}),"\n",(0,r.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,r.jsx)(n.p,{children:"Input: a 2D grid; Output: the maximum area of an island."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input:\n[[1,0,1,1,0,1,0,1],\n[1,0,1,1,0,1,1,1],\n[0,0,0,0,0,0,0,1]]\nOutput: 6\n"})}),"\n",(0,r.jsx)(n.p,{children:"The maximum area of an island is 6, located at the far right."}),"\n",(0,r.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,r.jsx)(n.p,{children:"This is a standard search problem, ideal for practicing DFS. Typically, DFS problems are divided into a main function for traversing all positions and a helper function for the recursive DFS. While DFS can also be implemented using a stack, recursion is often more convenient for competitive programming due to easier implementation and backtracking. However, in real-world engineering, a stack may be preferable to avoid recursion stack overflow and for easier understanding."}),"\n",(0,r.jsxs)(n.p,{children:["Below is the stack implementation. A small trick is used for traversal directions: an array ",(0,r.jsx)(n.code,{children:"[-1, 0, 1, 0, -1]"})," represents the four directions (up, down, left, right). You can also explicitly write ",(0,r.jsx)(n.code,{children:"[-1, 0]"}),", ",(0,r.jsx)(n.code,{children:"[1, 0]"}),", ",(0,r.jsx)(n.code,{children:"[0, 1]"}),", ",(0,r.jsx)(n.code,{children:"[0, -1]"})," for clarity."]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)(i,{value:"cpp",label:"C++",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"int maxAreaOfIsland(vector<vector<int>>& grid) {\n    vector<int> direction{-1, 0, 1, 0, -1};\n    int m = grid.size(), n = grid[0].size(), max_area = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                stack<pair<int, int>> island;\n                // Initialize the first node.\n                int local_area = 1;\n                grid[i][j] = 0;\n                island.push({i, j});\n                // DFS using stack.\n                while (!island.empty()) {\n                    auto [r, c] = island.top();\n                    island.pop();\n                    for (int k = 0; k < 4; ++k) {\n                        int x = r + direction[k], y = c + direction[k + 1];\n                        // Add neighboring nodes that meet the conditions.\n                        if (x >= 0 && x < m && y >= 0 && y < n &&\n                            grid[x][y] == 1) {\n                            ++local_area;\n                            grid[x][y] = 0;\n                            island.push({x, y});\n                        }\n                    }\n                }\n                max_area = max(max_area, local_area);\n            }\n        }\n    }\n    return max_area;\n}\n"})})}),(0,r.jsx)(i,{value:"py",label:"Python",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"def maxAreaOfIsland(grid: List[List[int]]) -> int:\n    direction = [-1, 0, 1, 0, -1]\n    m, n, max_area = len(grid), len(grid[0]), 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                island = []\n                # Initialize the first node.\n                local_area = 1\n                grid[i][j] = 0\n                island.append((i, j))\n                # DFS using stack.\n                while island:\n                    r, c = island.pop()\n                    for k in range(4):\n                        x, y = r + direction[k], c + direction[k + 1]\n                        # Add neighboring nodes that meet the conditions.\n                        if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:\n                            local_area += 1\n                            grid[x][y] = 0\n                            island.append((x, y))\n                max_area = max(max_area, local_area)\n    return max_area\n"})})})]}),"\n",(0,r.jsx)(n.p,{children:"Below, we present the recursive implementation. Be sure to check the boundary conditions when performing recursive searches. This can be done either before calling the auxiliary function or at the beginning of the auxiliary function itself. In this example, we do not use the array [-1, 0, 1, 0, -1] for searching in four directions (up, down, left, and right). Instead, we explicitly write four different recursive functions. Either approach works, and readers can choose to master either one."}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)(i,{value:"cpp",label:"C++",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Auxiliary function.\nint dfs(vector<vector<int>>& grid, int r, int c) {\n    if (r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() ||\n        grid[r][c] == 0) {\n        return 0;\n    }\n    grid[r][c] = 0;\n    return (1 + dfs(grid, r + 1, c) + dfs(grid, r - 1, c) +\n            dfs(grid, r, c + 1) + dfs(grid, r, c - 1));\n}\n\n// Main function.\nint maxAreaOfIsland(vector<vector<int>>& grid) {\n    int max_area = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            max_area = max(max_area, dfs(grid, i, j));\n        }\n    }\n    return max_area;\n}\n"})})}),(0,r.jsx)(i,{value:"py",label:"Python",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"# Auxiliary function\ndef dfs(grid: List[List[int]], r: int, c: int) -> int:\n    if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0:\n        return 0\n    grid[r][c] = 0\n    return (1 + dfs(grid, r + 1, c) + dfs(grid, r - 1, c) +\n            dfs(grid, r, c + 1) + dfs(grid, r, c - 1))\n\n# Main function\ndef maxAreaOfIsland(grid: List[List[int]]) -> int:\n    max_area = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            max_area = max(max_area, dfs(grid, i, j))\n    return max_area\n"})})})]}),"\n",(0,r.jsx)(n.h2,{id:"547-number-of-provinces",children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-provinces/",children:"547. Number of Provinces"})}),"\n",(0,r.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,r.jsx)(n.p,{children:"Given a 2D 0-1 matrix, if position (i, j) is 1, it means city i and city j belong to the same province. The adjacency relationship between cities is transitive; for example, if city a is connected to city b, and city b is connected to city c, then city a and city c are also connected, meaning they are part of the same province. The task is to calculate the total number of provinces."}),"\n",(0,r.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,r.jsx)(n.p,{children:"The input is a 2D matrix, and the output is an integer representing the number of provinces. Since the adjacency relationship is symmetric, the 2D matrix is symmetric. Additionally, each city is part of its own province, so the diagonal values are all 1."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input:\n[[1,1,0],\n[1,1,0],\n[0,0,1]]\nOutput: 2\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, cities [1, 2] are in one province, and city [3] is in another province."}),"\n",(0,r.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,r.jsx)(n.p,{children:"In the previous problem, the graph was represented such that each position represented a node, and each node was adjacent to its top, bottom, left, and right neighbors. In this problem, each row (or column) represents a node, and each column (or row) indicates whether there is an adjacent node. The previous problem had \ud835\udc5a \xd7 \ud835\udc5b nodes, each with 4 edges; in this problem, there are \ud835\udc5b nodes, and each node can have up to \ud835\udc5b edges if it is connected to all other cities, or a minimum of 1 edge if it is its own province. Once the graph representation is understood, this problem is essentially the same as the previous one: finding the number of provinces (or clusters of connected nodes). Here, we use a recursive approach."}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"For problems involving connected nodes, we can also use the Union-Find algorithm to quickly manage connections and searches. This will be discussed in later sections."})}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)(i,{value:"cpp",label:"C++",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"// Auxiliary function\nvoid dfs(vector<vector<int>>& isConnected, int i, vector<bool>& visited) {\n    visited[i] = true;\n    for (int j = 0; j < isConnected.size(); ++j) {\n        if (isConnected[i][j] == 1 && !visited[j]) {\n            dfs(isConnected, j, visited);\n        }\n    }\n}\n\n// Main function\nint findCircleNum(vector<vector<int>>& isConnected) {\n    int n = isConnected.size(), count = 0;\n    // Prevent revisiting already searched nodes\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            dfs(isConnected, i, visited);\n            ++count;\n        }\n    }\n    return count;\n}\n"})})}),(0,r.jsx)(i,{value:"py",label:"Python",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"# Auxiliary function\ndef dfs(isConnected: List[List[int]], city: int, visited: Set[int]):\n    visited.add(city)\n    for i in range(len(isConnected)):\n        if isConnected[city][i] == 1 and i not in visited:\n            dfs(isConnected, i, visited)\n\n# Main function\ndef findCircleNum(isConnected: List[List[int]]) -> int:\n    count = 0\n    # Prevent revisiting already searched nodes\n    visited = set()\n    for i in range(len(isConnected)):\n        if i not in visited:\n            dfs(isConnected, i, visited)\n            count += 1\n    return count\n"})})})]}),"\n",(0,r.jsx)(n.h2,{id:"417-paci\ufb01c-atlantic-water-flow",children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/pacific-atlantic-water-flow/",children:"417. Paci\ufb01c Atlantic Water Flow"})}),"\n",(0,r.jsx)(n.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,r.jsx)(n.p,{children:"Given a 2D matrix of non-negative integers, each position represents the elevation height. Assume that the left and top edges are the Pacific Ocean, and the right and bottom edges are the Atlantic Ocean. Determine the positions from which water can flow down to both the Pacific and Atlantic Oceans. Water can only flow from a higher or equal elevation to a lower or equal elevation."}),"\n",(0,r.jsx)(n.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,r.jsx)(n.p,{children:"The input is a 2D array of non-negative integers representing the elevation heights. The output is a 2D array where the second dimension has a fixed size of 2, representing the coordinates of positions that satisfy the conditions."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input:\nPacific  ~  ~  ~  ~  ~\n    ~  1   2  2  3  (5) *\n    ~  3   2  3 (4) (4) *\n    ~  2   4 (5) 3   1 *\n    ~ (6) (7) 1  4   5 *\n    ~ (5)  1  1  2   4 *\n       *   *  *  *   * Atlantic\nOutput: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example, the areas marked with parentheses are the positions satisfying the condition."}),"\n",(0,r.jsx)(n.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,r.jsx)(n.p,{children:"The problem requires determining positions from which water can flow to both oceans. If we attempt to search all positions, the complexity could become very high without pruning. Instead, we can reverse the perspective: starting from both oceans and simulating water flowing upwards. By doing so, we only need to search the four edges of the matrix. After completing the search, we iterate through the matrix to identify positions that can be reached from both the Pacific and Atlantic Oceans."}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)(i,{value:"cpp",label:"C++",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"vector<int> direction{-1, 0, 1, 0, -1};\n// Auxiliary function\nvoid dfs(const vector<vector<int>>& heights, vector<vector<bool>>& can_reach,\n         int r, int c) {\n    if (can_reach[r][c]) {\n        return;\n    }\n    can_reach[r][c] = true;\n    for (int i = 0; i < 4; ++i) {\n        int x = r + direction[i], y = c + direction[i + 1];\n        if (x >= 0 && x < heights.size() && y >= 0 && y < heights[0].size() &&\n            heights[r][c] <= heights[x][y]) {\n            dfs(heights, can_reach, x, y);\n        }\n    }\n}\n\n// Main function\nvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n    int m = heights.size(), n = heights[0].size();\n    vector<vector<bool>> can_reach_p(m, vector<bool>(n, false));\n    vector<vector<bool>> can_reach_a(m, vector<bool>(n, false));\n    vector<vector<int>> can_reach_p_and_a;\n    for (int i = 0; i < m; ++i) {\n        dfs(heights, can_reach_p, i, 0);\n        dfs(heights, can_reach_a, i, n - 1);\n    }\n    for (int i = 0; i < n; ++i) {\n        dfs(heights, can_reach_p, 0, i);\n        dfs(heights, can_reach_a, m - 1, i);\n    }\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (can_reach_p[i][j] && can_reach_a[i][j]) {\n                can_reach_p_and_a.push_back({i, j});\n            }\n        }\n    }\n    return can_reach_p_and_a;\n}\n"})})}),(0,r.jsx)(i,{value:"py",label:"Python",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"direction = [-1, 0, 1, 0, -1]\n\n# Auxiliary function\ndef dfs(heights: List[List[int]], can_reach: List[List[int]], r: int, c: int):\n    if can_reach[r][c]:\n        return\n    can_reach[r][c] = True\n    for i in range(4):\n        x, y = r + direction[i], c + direction[i + 1]\n        if (x >= 0 and x < len(heights) and y >= 0 and y < len(heights[0]) and\n            heights[x][y] >= heights[r][c]):\n            dfs(heights, can_reach, x, y)\n\n# Main function\ndef pacificAtlantic(heights: List[List[int]]) -> List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    can_reach_p = [[False for _ in range(n)] for _ in range(m)]\n    can_reach_a = [[False for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        dfs(heights, can_reach_p, i, 0)\n        dfs(heights, can_reach_a, i, n - 1)\n    for j in range(n):\n        dfs(heights, can_reach_p, 0, j)\n        dfs(heights, can_reach_a, m - 1, j)\n    return [\n            [i, j] for i in range(m) for j in range(n)\n            if can_reach_p[i][j] and can_reach_a[i][j]\n        ]\n"})})})]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);