"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[6888],{2159:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"trees/13-7-exercises","title":"13.7 Exercises","description":"Basic Difficulty","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/13-trees/13-7-exercises.md","sourceDirName":"13-trees","slug":"/trees/13-7-exercises","permalink":"/leetcode_101/en/trees/13-7-exercises","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/13-trees/13-7-exercises.md","tags":[],"version":"current","sidebarPosition":74,"frontMatter":{"sidebar_position":74},"sidebar":"tutorialSidebar","previous":{"title":"13.6 Trie","permalink":"/leetcode_101/en/trees/13-6-trie"},"next":{"title":"14. \u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e09\uff1a\u56fe","permalink":"/leetcode_101/en/category/14-\u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e09\u56fe"}}');var s=t(4848),o=t(8453);const i={sidebar_position:74},a="13.7 Exercises",l={},d=[{value:"Basic Difficulty",id:"basic-difficulty",level:2},{value:"226. Invert Binary Tree",id:"226-invert-binary-tree",level:3},{value:"617. Merge Two Binary Trees",id:"617-merge-two-binary-trees",level:3},{value:"572. Subtree of Another Tree",id:"572-subtree-of-another-tree",level:3},{value:"404. Sum of Left Leaves",id:"404-sum-of-left-leaves",level:3},{value:"513. Find Bottom Left Tree Value",id:"513-find-bottom-left-tree-value",level:3},{value:"538. Convert BST to Greater Tree",id:"538-convert-bst-to-greater-tree",level:3},{value:"235. Lowest Common Ancestor of a Binary Search Tree",id:"235-lowest-common-ancestor-of-a-binary-search-tree",level:3},{value:"530. Minimum Absolute Difference in BST",id:"530-minimum-absolute-difference-in-bst",level:3},{value:"Advanced Difficulty",id:"advanced-difficulty",level:2},{value:"1530. Number of Good Leaf Nodes Pairs",id:"1530-number-of-good-leaf-nodes-pairs",level:3},{value:"889. Construct Binary Tree from Preorder and Postorder Traversal",id:"889-construct-binary-tree-from-preorder-and-postorder-traversal",level:3},{value:"106. Construct Binary Tree from Inorder and Postorder Traversal",id:"106-construct-binary-tree-from-inorder-and-postorder-traversal",level:3},{value:"94. Binary Tree Inorder Traversal",id:"94-binary-tree-inorder-traversal",level:3},{value:"145. Binary Tree Postorder Traversal",id:"145-binary-tree-postorder-traversal",level:3},{value:"236. Lowest Common Ancestor of a Binary Tree",id:"236-lowest-common-ancestor-of-a-binary-tree",level:3},{value:"109. Convert Sorted List to Binary Search Tree",id:"109-convert-sorted-list-to-binary-search-tree",level:3},{value:"897. Increasing Order Search Tree",id:"897-increasing-order-search-tree",level:3},{value:"653. Two Sum IV - Input is a BST",id:"653-two-sum-iv---input-is-a-bst",level:3},{value:"450. Delete Node in a BST",id:"450-delete-node-in-a-bst",level:3}];function c(e){const r={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"137-exercises",children:"13.7 Exercises"})}),"\n",(0,s.jsx)(r.h2,{id:"basic-difficulty",children:"Basic Difficulty"}),"\n",(0,s.jsx)(r.h3,{id:"226-invert-binary-tree",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/invert-binary-tree/",children:"226. Invert Binary Tree"})}),"\n",(0,s.jsx)(r.p,{children:"With a clever use of recursion, you can complete this task in just five lines."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"617-merge-two-binary-trees",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/merge-two-binary-trees/",children:"617. Merge Two Binary Trees"})}),"\n",(0,s.jsx)(r.p,{children:"Similarly, recursion can easily handle this task."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"572-subtree-of-another-tree",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/subtree-of-another-tree/",children:"572. Subtree of Another Tree"})}),"\n",(0,s.jsx)(r.p,{children:"This is the sister problem of Symmetric Tree, and the implementation is very similar."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"404-sum-of-left-leaves",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/sum-of-left-leaves/",children:"404. Sum of Left Leaves"})}),"\n",(0,s.jsx)(r.p,{children:"How can you determine if a node is a left leaf? One feasible approach is to pass an additional parameter to the helper function indicating whether the current node is a left child of its parent."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"513-find-bottom-left-tree-value",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/find-bottom-left-tree-value/",children:"513. Find Bottom Left Tree Value"})}),"\n",(0,s.jsx)(r.p,{children:"What condition must the bottom-left node satisfy? How can we locate it based on this condition?"}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"538-convert-bst-to-greater-tree",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/convert-bst-to-greater-tree/",children:"538. Convert BST to Greater Tree"})}),"\n",(0,s.jsx)(r.p,{children:"Try to solve this problem using a specific traversal method, visiting each node exactly once."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"235-lowest-common-ancestor-of-a-binary-search-tree",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",children:"235. Lowest Common Ancestor of a Binary Search Tree"})}),"\n",(0,s.jsx)(r.p,{children:"Using the unique properties of a BST, this problem can be solved quite easily."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"530-minimum-absolute-difference-in-bst",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/minimum-absolute-difference-in-bst/",children:"530. Minimum Absolute Difference in BST"})}),"\n",(0,s.jsx)(r.p,{children:"Remember the traversal method we discussed for BSTs?"}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"advanced-difficulty",children:"Advanced Difficulty"}),"\n",(0,s.jsx)(r.h3,{id:"1530-number-of-good-leaf-nodes-pairs",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/",children:"1530. Number of Good Leaf Nodes Pairs"})}),"\n",(0,s.jsx)(r.p,{children:"A variation of problem 543. Pay attention in the helper function: the global variable should be updated based on the number of valid pairs of distances between left and right subtrees, while the return value is the height of all valid leaf nodes (+1) from both subtrees."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"889-construct-binary-tree-from-preorder-and-postorder-traversal",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/",children:"889. Construct Binary Tree from Preorder and Postorder Traversal"})}),"\n",(0,s.jsx)(r.p,{children:"Given any two traversal results, we can reconstruct the tree structure."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"106-construct-binary-tree-from-inorder-and-postorder-traversal",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",children:"106. Construct Binary Tree from Inorder and Postorder Traversal"})}),"\n",(0,s.jsx)(r.p,{children:"Given any two traversal results, we can reconstruct the tree structure."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"94-binary-tree-inorder-traversal",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/binary-tree-inorder-traversal/",children:"94. Binary Tree Inorder Traversal"})}),"\n",(0,s.jsx)(r.p,{children:"Since preorder, inorder, and postorder traversals are implemented using recursion, and recursion inherently uses a stack, we can always use a stack to implement them."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"145-binary-tree-postorder-traversal",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/binary-tree-postorder-traversal/",children:"145. Binary Tree Postorder Traversal"})}),"\n",(0,s.jsx)(r.p,{children:"Since preorder, inorder, and postorder traversals are implemented using recursion, and recursion inherently uses a stack, we can always use a stack to implement them."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"236-lowest-common-ancestor-of-a-binary-tree",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",children:"236. Lowest Common Ancestor of a Binary Tree"})}),"\n",(0,s.jsx)(r.p,{children:"Now it\u2019s not a BST but a general binary tree. What should we do?"}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"109-convert-sorted-list-to-binary-search-tree",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/",children:"109. Convert Sorted List to Binary Search Tree"})}),"\n",(0,s.jsx)(r.p,{children:"Convert a sorted linked list into a BST. To ensure the BST remains balanced, we need to find the middle point of the list."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"897-increasing-order-search-tree",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/increasing-order-search-tree/",children:"897. Increasing Order Search Tree"})}),"\n",(0,s.jsx)(r.p,{children:"Flatten a BST into a linked list. Be cautious about the order of pointer manipulations to avoid creating loops."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"653-two-sum-iv---input-is-a-bst",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",children:"653. Two Sum IV - Input is a BST"})}),"\n",(0,s.jsx)(r.p,{children:"Ah, this problem might trick you."}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"450-delete-node-in-a-bst",children:(0,s.jsx)(r.a,{href:"https://leetcode.com/problems/delete-node-in-a-bst/",children:"450. Delete Node in a BST"})}),"\n",(0,s.jsx)(r.p,{children:"When you locate the node to delete, consider different cases: whether the node is a leaf, has only one child, or has two children. It\u2019s recommended to reclaim memory at the same time."})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);