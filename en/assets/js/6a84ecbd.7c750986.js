"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[6586],{5009:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"data-structures/10-6-priority-queue","title":"10.6 Priority Queue","description":"Priority queue allows retrieving the maximum value in $O(1)$ time and inserting or removing the maximum value in $O(\\\\log n)$ time.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/10-data-structures/10-6-priority-queue.mdx","sourceDirName":"10-data-structures","slug":"/data-structures/10-6-priority-queue","permalink":"/leetcode_101/en/data-structures/10-6-priority-queue","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":53,"frontMatter":{"sidebar_position":53},"sidebar":"tutorialSidebar","previous":{"title":"10.5 Monotonic Stack","permalink":"/leetcode_101/en/data-structures/10-5-monotonic-stack"},"next":{"title":"10.7 Double-Ended Queue","permalink":"/leetcode_101/en/data-structures/10-7-deque"}}');var a=s(4848),t=s(8453);const l={sidebar_position:53},r="10.6 Priority Queue",p={},o=[{value:"23. Merge k Sorted Lists",id:"23-merge-k-sorted-lists",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"218. The Skyline Problem",id:"218-the-skyline-problem",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3}];function h(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,t.R)(),...e.components},{TabItem:i,Tabs:l}=n;return i||d("TabItem",!0),l||d("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"106-priority-queue",children:"10.6 Priority Queue"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Priority queue"})," allows retrieving the maximum value in ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mn,{children:"1"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord",children:"1"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})})]})," time and inserting or removing the maximum value in ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"log"}),(0,a.jsx)(n.mo,{children:"\u2061"}),(0,a.jsx)(n.mi,{children:"n"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(\\log n)"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsxs)(n.span,{className:"mop",children:["lo",(0,a.jsx)(n.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})})]})," time."]}),"\n",(0,a.jsxs)("figure",{children:[(0,a.jsx)("span",{style:{display:"block",width:"50%",margin:"0 auto"},children:(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:s(2742).A+"",width:"1200",height:"889"})})}),(0,a.jsx)("figcaption",{style:{textAlign:"center"},children:'Figure 10.2: (Max) Heap, maintaining the "greater than" relationship in the data structure'})]}),"\n",(0,a.jsxs)(n.p,{children:["Priority queues are often implemented using heaps. A heap is a complete binary tree in which each node's value is always greater than or equal to its child nodes. When implementing heaps, arrays are often used instead of pointers to build a tree. This is because heaps are complete binary trees, so in an array representation, the parent node of position ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"i"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"i"})]})})]})," is located at ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"i"}),(0,a.jsx)(n.mo,{children:"\u2212"}),(0,a.jsx)(n.mn,{children:"1"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"}),(0,a.jsx)(n.mi,{mathvariant:"normal",children:"/"}),(0,a.jsx)(n.mn,{children:"2"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"(i-1)/2"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\u2212"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord",children:"1"}),(0,a.jsx)(n.span,{className:"mclose",children:")"}),(0,a.jsx)(n.span,{className:"mord",children:"/2"})]})]})]}),", and its two child nodes are located at ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mn,{children:"2"}),(0,a.jsx)(n.mi,{children:"i"}),(0,a.jsx)(n.mo,{children:"+"}),(0,a.jsx)(n.mn,{children:"1"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"2i+1"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.7429em",verticalAlign:"-0.0833em"}}),(0,a.jsx)(n.span,{className:"mord",children:"2"}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"+"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"1"})]})]})]})," and ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mn,{children:"2"}),(0,a.jsx)(n.mi,{children:"i"}),(0,a.jsx)(n.mo,{children:"+"}),(0,a.jsx)(n.mn,{children:"2"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"2i+2"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.7429em",verticalAlign:"-0.0833em"}}),(0,a.jsx)(n.span,{className:"mord",children:"2"}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"+"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(n.span,{className:"mord",children:"2"})]})]})]}),", respectively."]}),"\n",(0,a.jsx)(n.p,{children:'Here is the implementation of heaps. The two core operations are "swim" and "sink": if a node is greater than its parent node, we swap them; after swapping, it may still be greater than its new parent node, so we continue comparing and swapping, known as "swim." Similarly, if a node is smaller than its parent, it needs to compare and swap downward continuously, known as "sink." If a node has two child nodes, we always swap with the largest child node.'}),"\n",(0,a.jsxs)(l,{children:[(0,a.jsx)(i,{value:"cpp",label:"C++",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"class Heap {\n   public:\n    Heap() {}\n    // Swim\n    void swim(int pos) {\n        int next_pos = (pos - 1) / 2;\n        while (pos > 0 && heap_[next_pos] < heap_[pos]) {\n            swap(heap_[next_pos], heap_[pos]);\n            pos = next_pos;\n            next_pos = (pos - 1) / 2;\n        }\n    }\n    // Sink\n    void sink(int pos) {\n        int n = heap_.size();\n        int next_pos = 2 * pos + 1;\n        while (next_pos < n) {\n            if (next_pos < n - 1 && heap_[next_pos] < heap_[next_pos + 1]) {\n                ++next_pos;\n            }\n            if (heap_[pos] >= heap_[next_pos]) {\n                break;\n            }\n            swap(heap_[next_pos], heap_[pos]);\n            pos = next_pos;\n            next_pos = 2 * pos + 1;\n        }\n    }\n    // Insert any value: place the new number at the last position, then swim.\n    void push(int k) {\n        heap_.push_back(k);\n        swim(heap_.size() - 1);\n    }\n    // Delete the maximum value: move the last number to the front, then sink.\n    void pop() {\n        heap_[0] = heap_.back();\n        heap_.pop_back();\n        sink(0);\n    }\n    // Retrieve the maximum value.\n    int top() { return heap_[0]; }\n\n   private:\n    vector<int> heap_;\n};\n"})})}),(0,a.jsx)(i,{value:"py",label:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"class Heap:\n    def __init__(self):\n        self.heap = []\n\n    # Swim\n    def swim(self, pos: int):\n        next_pos = (pos - 1) // 2\n        while pos > 0 and self.heap[next_pos] < self.heap[pos]:\n            self.heap[next_pos], self.heap[pos] = self.heap[pos], self.heap[next_pos]\n            pos = next_pos\n            next_pos = (pos - 1) // 2\n\n    # Sink\n    def sink(self, pos: int):\n        n = len(self.heap)\n        next_pos = 2 * pos + 1\n        while next_pos < n:\n            if next_pos < n - 1 and self.heap[next_pos] < self.heap[next_pos + 1]:\n                next_pos += 1\n            if self.heap[pos] >= self.heap[next_pos]:\n                break\n            self.heap[next_pos], self.heap[pos] = self.heap[pos], self.heap[next_pos]\n            pos = next_pos\n            next_pos = 2 * pos + 1\n\n    # Insert any value: place the new number at the last position, then swim.\n    def push(self, k: int):\n        self.heap.append(k)\n        self.swim(len(self.heap) - 1)\n\n    # Delete the maximum value: move the last number to the front, then sink.\n    def pop(self):\n        self.heap[0] = self.heap.pop()\n        self.sink(0)\n\n    # Retrieve the maximum value.\n    def top(self) -> int:\n        return self.heap[0]\n\n"})})})]}),"\n",(0,a.jsx)(n.p,{children:"By swapping the greater-than and less-than operators in the algorithm, we can also create a priority queue that retrieves the minimum value quickly."}),"\n",(0,a.jsx)(n.h2,{id:"23-merge-k-sorted-lists",children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/merge-k-sorted-lists/",children:"23. Merge k Sorted Lists"})}),"\n",(0,a.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,a.jsxs)(n.p,{children:["Given ",(0,a.jsx)(n.code,{children:"k"})," sorted linked lists, try to merge them into one sorted linked list."]}),"\n",(0,a.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,a.jsx)(n.p,{children:"The input is a one-dimensional array, where each position stores the head node of a linked list; the output is a single linked list."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input:\n[1->4->5,\n 1->3->4,\n 2->6]\nOutput: 1->1->2->3->4->4->5->6\n"})}),"\n",(0,a.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,a.jsx)(n.p,{children:"There are multiple ways to solve this problem, such as using a merge sort-like approach to merge the lists pair by pair. Here, we demonstrate a faster method: store all the linked lists in a priority queue and extract the node with the smallest value from the head of all lists at each step until all lists have been completely merged."}),"\n",(0,a.jsxs)(n.p,{children:["Since the default comparison function of a C++ ",(0,a.jsx)(n.code,{children:"priority_queue"})," is for a max-heap and maintains an increasing order, to get the smallest node values, we need to implement a min-heap. Thus, the comparison function for the heap should maintain a decreasing order, i.e., the lambda function should use the greater-than operator instead of the less-than operator used for increasing order."]}),"\n",(0,a.jsxs)(l,{children:[(0,a.jsx)(i,{value:"cpp",label:"C++",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"ListNode* mergeKLists(vector<ListNode*>& lists) {\n    auto comp = [](ListNode* l1, ListNode* l2) { return l1->val > l2->val; };\n    priority_queue<ListNode*, vector<ListNode*>, decltype(comp)> pq;\n    for (ListNode* l : lists) {\n        if (l) {\n            pq.push(l);\n        }\n    }\n    ListNode *dummy = new ListNode(0), *cur = dummy;\n    while (!pq.empty()) {\n        cur->next = pq.top();\n        pq.pop();\n        cur = cur->next;\n        if (cur->next) {\n            pq.push(cur->next);\n        }\n    }\n    return dummy->next;\n}\n"})})}),(0,a.jsx)(i,{value:"py",label:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n    pq = []\n    for idx, l in enumerate(lists):\n        if l is not None:\n            # ListNode cannot be hashed, so we directly record its position in lists.\n            pq.append((l.val, idx))\n    heapq.heapify(pq)\n    \n    dummy = ListNode()\n    cur = dummy\n    \n    while len(pq) > 0:\n        _, l_idx = heapq.heappop(pq)\n        cur.next = lists[l_idx]\n        cur = cur.next\n        if cur.next is not None:\n            lists[l_idx] = lists[l_idx].next\n            heapq.heappush(pq, (cur.next.val, l_idx))\n    \n    return dummy.next\n\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"218-the-skyline-problem",children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/the-skyline-problem/",children:"218. The Skyline Problem"})}),"\n",(0,a.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,a.jsx)(n.p,{children:"Given the start and end positions along with the height of buildings, return the critical points of the building's silhouette (skyline)."}),"\n",(0,a.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,a.jsxs)(n.p,{children:["The input is a 2D integer array representing each building as ",(0,a.jsx)(n.code,{children:"[left, right, height]"}),"; the output is a 2D integer array representing the x and y coordinates of the critical points of the skyline."]}),"\n",(0,a.jsxs)("figure",{children:[(0,a.jsx)("span",{style:{display:"block",width:"90%",margin:"0 auto"},children:(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:s(6543).A+"",width:"2000",height:"800"})})}),(0,a.jsx)("figcaption",{style:{textAlign:"center"},children:"Figure 10.3: Problem 218 - Example of buildings and their skyline"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input: [[2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8]]\nOutput: [[2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0]]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,a.jsx)(n.p,{children:"We can use a priority queue to store the height and the right endpoint of each building (using a pair). This helps us identify the next building that raises the skyline and interferes with the previous building's endpoint."}),"\n",(0,a.jsxs)(n.p,{children:["Since Python's ",(0,a.jsx)(n.code,{children:"heapq"})," implements a min-heap, we store negative values for heights to simulate a max-heap."]}),"\n",(0,a.jsx)(n.p,{children:"This problem is relatively complex. If you find it challenging to grasp, consider skipping it for now or illustrating examples on paper for better understanding."}),"\n",(0,a.jsxs)(l,{children:[(0,a.jsx)(i,{value:"cpp",label:"C++",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n    vector<vector<int>> skyline;\n    priority_queue<pair<int, int>> pq;  // <height, right>\n    int i = 0, n = buildings.size();\n    int cur_x, cur_h;\n    while (i < n || !pq.empty()) {\n        if (pq.empty() || (i < n && buildings[i][0] <= pq.top().second)) {\n            cur_x = buildings[i][0];\n            while (i < n && cur_x == buildings[i][0]) {\n                pq.emplace(buildings[i][2], buildings[i][1]);\n                ++i;\n            }\n        } else {\n            cur_x = pq.top().second;\n            while (!pq.empty() && cur_x >= pq.top().second) {\n                pq.pop();\n            }\n        }\n        cur_h = pq.empty() ? 0 : pq.top().first;\n        if (skyline.empty() || cur_h != skyline.back()[1]) {\n            skyline.push_back({cur_x, cur_h});\n        }\n    }\n    return skyline;\n}\n"})})}),(0,a.jsx)(i,{value:"py",label:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"def getSkyline(buildings: List[List[int]]) -> List[List[int]]:\n    skyline = []\n    pq = []  # <negative height, right>\n    heapq.heapify(pq)\n    i, n = 0, len(buildings)\n    \n    while i < n or len(pq) > 0:\n        if len(pq) == 0 or (i < n and buildings[i][0] <= pq[0][1]):\n            cur_x = buildings[i][0]\n            while i < n and cur_x == buildings[i][0]:\n                heapq.heappush(pq, (-buildings[i][2], buildings[i][1]))\n                i += 1\n        else:\n            cur_x = pq[0][1]\n            while len(pq) > 0 and cur_x >= pq[0][1]:\n                heapq.heappop(pq)\n        \n        cur_h = -pq[0][0] if len(pq) > 0 else 0\n        if len(skyline) == 0 or cur_h != skyline[-1][1]:\n            skyline.append([cur_x, cur_h])\n    \n    return skyline\n\n"})})})]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}function d(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},2742:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/10.2-a73e084fc742289b88c9fd1d46e997df.png"},6543:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/10.3-016f1aab3e24ba87beaf329ee6c2a4a7.png"}}]);