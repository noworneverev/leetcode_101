"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[4406],{8764:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"trees/13-3-level-order-traversal","title":"13.3 Level Order Traversal","description":"We can use Breadth-First Search (BFS) for level order traversal. Note that it is unnecessary to use two queues to separately store the current layer\'s nodes and the next layer\'s nodes. At the beginning of each layer\'s traversal, the number of nodes in the current queue equals the number of nodes in the current layer. By controlling the traversal to only process that many nodes, we ensure that the traversal covers only the current layer.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/13-trees/13-3-level-order-traversal.mdx","sourceDirName":"13-trees","slug":"/trees/13-3-level-order-traversal","permalink":"/leetcode_101/en/trees/13-3-level-order-traversal","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":70,"frontMatter":{"sidebar_position":70},"sidebar":"tutorialSidebar","previous":{"title":"13.2 Tree Recursion","permalink":"/leetcode_101/en/trees/13-2-tree-recursion"},"next":{"title":"13.4  Preorder, Inorder, and Postorder Traversals","permalink":"/leetcode_101/en/trees/13-4-preorder-inorder-postorder-traversal"}}');var l=r(4848),o=r(8453);const a={sidebar_position:70},s="13.3 Level Order Traversal",i={},d=[{value:"637. Average of Levels in Binary Tree",id:"637-average-of-levels-in-binary-tree",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components},{TabItem:r,Tabs:t}=n;return r||v("TabItem",!0),t||v("Tabs",!0),(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"133-level-order-traversal",children:"13.3 Level Order Traversal"})}),"\n",(0,l.jsx)(n.p,{children:"We can use Breadth-First Search (BFS) for level order traversal. Note that it is unnecessary to use two queues to separately store the current layer's nodes and the next layer's nodes. At the beginning of each layer's traversal, the number of nodes in the current queue equals the number of nodes in the current layer. By controlling the traversal to only process that many nodes, we ensure that the traversal covers only the current layer."}),"\n",(0,l.jsx)(n.h2,{id:"637-average-of-levels-in-binary-tree",children:(0,l.jsx)(n.a,{href:"https://leetcode.com/problems/average-of-levels-in-binary-tree/",children:"637. Average of Levels in Binary Tree"})}),"\n",(0,l.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,l.jsx)(n.p,{children:"Given a binary tree, compute the average value of nodes at each level."}),"\n",(0,l.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,l.jsx)(n.p,{children:"Input is a binary tree, and the output is a one-dimensional array representing the average value of nodes at each level."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"Input:\n    3\n   / \\\n  9  20\n     / \\\n    15  7\nOutput: [3, 14.5, 11]\n"})}),"\n",(0,l.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,l.jsx)(n.p,{children:"Using Breadth-First Search, we can conveniently calculate the average value for each level."}),"\n",(0,l.jsxs)(t,{children:[(0,l.jsx)(r,{value:"cpp",label:"C++",children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",children:"vector<double> averageOfLevels(TreeNode* root) {\n    vector<double> level_avg;\n    if (root == nullptr) {\n        return level_avg;\n    }\n    queue<TreeNode*> q;\n    q.push(root);\n    int count = q.size();\n    while (count > 0) {\n        double level_sum = 0;\n        for (int i = 0; i < count; ++i) {\n            TreeNode* node = q.front();\n            q.pop();\n            level_sum += node->val;\n            if (node->left != nullptr) {\n                q.push(node->left);\n            }\n            if (node->right != nullptr) {\n                q.push(node->right);\n            }\n        }\n        level_avg.push_back(level_sum / count);\n        count = q.size();\n    }\n    return level_avg;\n}\n"})})}),(0,l.jsx)(r,{value:"py",label:"Python",children:(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-py",children:"def averageOfLevels(root: Optional[TreeNode]) -> List[float]:\n    level_avg = []\n    if root is None:\n        return level_avg\n    q = collections.deque()\n    q.append(root)\n    count = len(q)\n    while count > 0:\n        level_sum = 0\n        for _ in range(count):\n            node = q.popleft()\n            level_sum += node.val\n            if node.left is not None:\n                q.append(node.left)\n            if node.right is not None:\n                q.append(node.right)\n        level_avg.append(level_sum / count)\n        count = len(q)\n    return level_avg\n"})})})]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(u,{...e})}):u(e)}function v(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);