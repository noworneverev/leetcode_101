"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[9994],{8158:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>d,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"trees/13-4-preorder-inorder-postorder-traversal","title":"13.4  Preorder, Inorder, and Postorder Traversals","description":"Preorder traversal, inorder traversal, and postorder traversal are three ways to traverse a binary tree using Depth-First Search (DFS). They differ only in the order of node visits, while the rest remains the same. Consider the following binary tree:","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/13-trees/13-4-preorder-inorder-postorder-traversal.mdx","sourceDirName":"13-trees","slug":"/trees/13-4-preorder-inorder-postorder-traversal","permalink":"/leetcode_101/en/trees/13-4-preorder-inorder-postorder-traversal","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/13-trees/13-4-preorder-inorder-postorder-traversal.mdx","tags":[],"version":"current","sidebarPosition":71,"frontMatter":{"sidebar_position":71},"sidebar":"tutorialSidebar","previous":{"title":"13.3 Level Order Traversal","permalink":"/leetcode_101/en/trees/13-3-level-order-traversal"},"next":{"title":"13.5 Binary Search Tree","permalink":"/leetcode_101/en/trees/13-5-binary-search-tree"}}');var o=n(4848),i=n(8453);const d={sidebar_position:71},s="13.4  Preorder, Inorder, and Postorder Traversals",l={},a=[{value:"105. Construct Binary Tree from Preorder and Inorder Traversal",id:"105-construct-binary-tree-from-preorder-and-inorder-traversal",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"144. Binary Tree Preorder Traversal",id:"144-binary-tree-preorder-traversal",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3}];function p(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{TabItem:n,Tabs:t}=r;return n||h("TabItem",!0),t||h("Tabs",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"134--preorder-inorder-and-postorder-traversals",children:"13.4  Preorder, Inorder, and Postorder Traversals"})}),"\n",(0,o.jsx)(r.p,{children:"Preorder traversal, inorder traversal, and postorder traversal are three ways to traverse a binary tree using Depth-First Search (DFS). They differ only in the order of node visits, while the rest remains the same. Consider the following binary tree:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"    1\n   / \\\n  2   3\n / \\   \\\n4   5   6\n"})}),"\n",(0,o.jsxs)(r.p,{children:["In ",(0,o.jsx)(r.strong,{children:"preorder traversal"}),", the parent node is visited first, followed by the left node and then the right node. The traversal order is [1 2 4 5 3 6]."]}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)(n,{value:"cpp",label:"C++",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-cpp",children:"void preorder(TreeNode* root) {\n    visit(root);\n    preorder(root->left);\n    preorder(root->right);\n}\n"})})}),(0,o.jsx)(n,{value:"py",label:"Python",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-py",children:"def preorder(root: TreeNode):\n    visit(root)\n    preorder(root.left)\n    preorder(root.right)\n"})})})]}),"\n",(0,o.jsxs)(r.p,{children:["In ",(0,o.jsx)(r.strong,{children:"inorder traversal"}),", the left node is visited first, followed by the parent node and then the right node. The traversal order is [4 2 5 1 3 6]."]}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)(n,{value:"cpp",label:"C++",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-cpp",children:"void inorder(TreeNode* root) {\n    inorder(root->left);\n    visit(root);\n    inorder(root->right);\n}\n"})})}),(0,o.jsx)(n,{value:"py",label:"Python",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-py",children:"def inorder(root: TreeNode):\n    inorder(root.left)\n    visit(root)\n    inorder(root.right)\n"})})})]}),"\n",(0,o.jsxs)(r.p,{children:["In ",(0,o.jsx)(r.strong,{children:"postorder traversal"}),", the left node is visited first, followed by the right node and then the parent node. The traversal order is [4 5 2 6 3 1]."]}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)(n,{value:"cpp",label:"C++",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-cpp",children:"void postorder(TreeNode* root) {\n    postorder(root->left);\n    postorder(root->right);\n    visit(root);\n}\n"})})}),(0,o.jsx)(n,{value:"py",label:"Python",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-py",children:"def postorder(root: TreeNode):\n    postorder(root.left)\n    postorder(root.right)\n    visit(root)\n"})})})]}),"\n",(0,o.jsx)(r.h2,{id:"105-construct-binary-tree-from-preorder-and-inorder-traversal",children:(0,o.jsx)(r.a,{href:"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",children:"105. Construct Binary Tree from Preorder and Inorder Traversal"})}),"\n",(0,o.jsx)(r.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,o.jsx)(r.p,{children:"Given the preorder and inorder traversal results of a binary tree, reconstruct the tree. It is guaranteed that there are no duplicate values in the tree nodes."}),"\n",(0,o.jsx)(r.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,o.jsx)(r.p,{children:"Input consists of two 1D arrays representing the preorder and inorder traversal results of the tree. Output is the reconstructed binary tree."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"Input: preorder = [4,9,20,15,7], inorder = [9,4,15,20,7]\nOutput:\n    4\n   / \\\n  9  20\n     / \\\n    15  7\n"})}),"\n",(0,o.jsx)(r.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,o.jsxs)(r.p,{children:["Using the provided example, the first node in the preorder traversal is ",(0,o.jsx)(r.code,{children:"4"}),", indicating that ",(0,o.jsx)(r.code,{children:"4"})," is the root node. In the inorder traversal, locating ",(0,o.jsx)(r.code,{children:"4"})," provides the following insights:"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:["The left subarray in the inorder traversal corresponds to the left subtree. It contains ",(0,o.jsx)(r.code,{children:"1"})," node (",(0,o.jsx)(r.code,{children:"9"}),"), which maps to the next ",(0,o.jsx)(r.code,{children:"1"})," element in the preorder traversal after ",(0,o.jsx)(r.code,{children:"4"}),"."]}),"\n",(0,o.jsxs)(r.li,{children:["The right subarray in the inorder traversal corresponds to the right subtree. It contains ",(0,o.jsx)(r.code,{children:"3"})," nodes (",(0,o.jsx)(r.code,{children:"15"}),", ",(0,o.jsx)(r.code,{children:"20"}),", ",(0,o.jsx)(r.code,{children:"7"}),"), which map to the last ",(0,o.jsx)(r.code,{children:"3"})," elements in the preorder traversal."]}),"\n"]}),"\n",(0,o.jsx)(r.p,{children:"With this information, the left and right subtrees can be recursively reconstructed. To simplify locating values, a hash map can be used to preprocess the inorder traversal results."}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)(n,{value:"cpp",label:"C++",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-cpp",children:"// Auxiliary function\nTreeNode* reconstruct(unordered_map<int, int>& io_map, vector<int>& po, int l,\n                      int r, int mid_po) {\n    if (l > r) {\n        return nullptr;\n    }\n    int mid_val = po[mid_po];\n    int mid_io = io_map[mid_val];\n    int left_len = mid_io - l + 1;\n    TreeNode* node = new TreeNode(mid_val);\n    node->left = reconstruct(io_map, po, l, mid_io - 1, mid_po + 1);\n    node->right = reconstruct(io_map, po, mid_io + 1, r, mid_po + left_len);\n    return node;\n}\n// Main function\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n    unordered_map<int, int> io_map;\n    for (int i = 0; i < inorder.size(); ++i) {\n        io_map[inorder[i]] = i;\n    }\n    return reconstruct(io_map, preorder, 0, preorder.size() - 1, 0);\n}\n"})})}),(0,o.jsx)(n,{value:"py",label:"Python",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-py",children:"# Auxiliary function\ndef reconstruct(\n    io_map: Dict[int, int], po: List[int], l: int, r: int, mid_po: int\n) -> Optional[TreeNode]:\n    if l > r:\n        return None\n    mid_val = po[mid_po]\n    mid_io = io_map[mid_val]\n    left_len = mid_io - l + 1\n    node = TreeNode(mid_val)\n    node.left = reconstruct(io_map, po, l, mid_io - 1, mid_po + 1)\n    node.right = reconstruct(io_map, po, mid_io + 1, r, mid_po + left_len)\n    return node\n\n# Main function\ndef buildTree(preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n    io_map = {val: i for i, val in enumerate(inorder)}\n    return reconstruct(io_map, preorder, 0, len(preorder) - 1, 0)\n\n"})})})]}),"\n",(0,o.jsx)(r.h2,{id:"144-binary-tree-preorder-traversal",children:(0,o.jsx)(r.a,{href:"https://leetcode.com/problems/binary-tree-preorder-traversal/",children:"144. Binary Tree Preorder Traversal"})}),"\n",(0,o.jsx)(r.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,o.jsx)(r.p,{children:"Implement a binary tree preorder traversal without using recursion."}),"\n",(0,o.jsx)(r.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,o.jsx)(r.p,{children:"Input is a binary tree, and the output is an array representing the preorder traversal of the binary tree."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"Input:\n    1\n     \\\n      2\n     /\n    3\nOutput: [1,2,3]\n"})}),"\n",(0,o.jsx)(r.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,o.jsx)(r.p,{children:"Since recursion inherently uses a stack, we can simulate the preorder traversal using an explicit stack. Note the order of stack operations."}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)(n,{value:"cpp",label:"C++",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-cpp",children:"vector<int> preorderTraversal(TreeNode* root) {\n    vector<int> po;\n    if (root == nullptr) {\n        return po;\n    }\n    stack<TreeNode*> s;\n    s.push(root);\n    while (!s.empty()) {\n        TreeNode* node = s.top();\n        s.pop();\n        po.push_back(node->val);\n        if (node->right) {\n            s.push(node->right);  // Push the right child first, then the left child, to ensure the left subtree is traversed first.\n        }\n        if (node->left) {\n            s.push(node->left);\n        }\n    }\n    return po;\n}\n"})})}),(0,o.jsx)(n,{value:"py",label:"Python",children:(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-py",children:"def preorderTraversal(root: Optional[TreeNode]) -> List[int]:\n    po = []\n    if root is None:\n        return po\n    s = [root]\n    while len(s) > 0:\n        node = s.pop()\n        po.append(node.val)\n        if node.right is not None:\n            s.append(node.right)  # Push the right child first, then the left child, to ensure the left subtree is traversed first.\n        if node.left is not None:\n            s.append(node.left)\n    return po\n"})})})]})]})}function c(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}function h(e,r){throw new Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);