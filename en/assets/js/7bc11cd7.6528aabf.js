"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[2943],{7070:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>m});const a=JSON.parse('{"id":"data-structures/10-10-prefix-sum-integral-image","title":"10.10 Prefix Sum and Integral Image","description":"A one-dimensional prefix sum (cumulative sum, cumsum) and a two-dimensional integral image (summed-area table, image integral) are techniques used to precompute the sums of one-dimensional segments or two-dimensional rectangles up to each position. This allows for faster calculations and queries. If you need to index values from the prefix sum or integral image, they can be stored in a hash table. If you need to record values for each position, they can be stored in one-dimensional or two-dimensional arrays, often in conjunction with dynamic programming.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/10-data-structures/10-10-prefix-sum-integral-image.mdx","sourceDirName":"10-data-structures","slug":"/data-structures/10-10-prefix-sum-integral-image","permalink":"/leetcode_101/en/data-structures/10-10-prefix-sum-integral-image","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":57,"frontMatter":{"sidebar_position":57},"sidebar":"tutorialSidebar","previous":{"title":"10.9 Multisets and Mappings","permalink":"/leetcode_101/en/data-structures/10-9-multisets-and-maps"},"next":{"title":"10.11 Exercises","permalink":"/leetcode_101/en/data-structures/10-11-exercises"}}');var t=s(4848),i=s(8453);const r={sidebar_position:57},l="10.10 Prefix Sum and Integral Image",c={},m=[{value:"303. Range Sum Query - Immutable",id:"303-range-sum-query---immutable",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"304. Range Sum Query 2D - Immutable",id:"304-range-sum-query-2d---immutable",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"560. Subarray Sum Equals K",id:"560-subarray-sum-equals-k",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3}];function o(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,i.R)(),...e.components},{TabItem:a,Tabs:r}=n;return a||d("TabItem",!0),r||d("Tabs",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"1010-prefix-sum-and-integral-image",children:"10.10 Prefix Sum and Integral Image"})}),"\n",(0,t.jsx)(n.p,{children:"A one-dimensional prefix sum (cumulative sum, cumsum) and a two-dimensional integral image (summed-area table, image integral) are techniques used to precompute the sums of one-dimensional segments or two-dimensional rectangles up to each position. This allows for faster calculations and queries. If you need to index values from the prefix sum or integral image, they can be stored in a hash table. If you need to record values for each position, they can be stored in one-dimensional or two-dimensional arrays, often in conjunction with dynamic programming."}),"\n",(0,t.jsx)(n.h2,{id:"303-range-sum-query---immutable",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/range-sum-query-immutable/",children:"303. Range Sum Query - Immutable"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Design a data structure to quickly query the sum of all numbers between any two positions in a given array."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,t.jsx)(n.p,{children:"Here is a sample usage of the data structure."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"vector<int> nums{-2,0,3,-5,2,-1};\nNumArray num_array = new NumArray(nums);\nnum_array.sumRange(0,2); // Result = -2+0+3 = 1.\nnum_array.sunRange(1,5); // Result = 0+3-5+2-1 = -1.\n"})}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["For a one-dimensional array, we can use a prefix sum to solve this problem. First, create a new array ",(0,t.jsx)(n.code,{children:"cumsum"})," of the same length as ",(0,t.jsx)(n.code,{children:"nums"}),", where each position in ",(0,t.jsx)(n.code,{children:"cumsum"})," stores the sum of all numbers in ",(0,t.jsx)(n.code,{children:"nums"})," up to that position. The ",(0,t.jsx)(n.code,{children:"cumsum"})," array can be built using the C++ ",(0,t.jsx)(n.code,{children:"partial_sum"})," function or by iterating through the ",(0,t.jsx)(n.code,{children:"nums"})," array and calculating it using the state transition formula ",(0,t.jsx)(n.code,{children:"cumsum[i] = cumsum[i-1] + nums[i]"}),". To obtain the sum of numbers between positions ",(0,t.jsx)(n.code,{children:"i"})," and ",(0,t.jsx)(n.code,{children:"j"}),", calculate ",(0,t.jsx)(n.code,{children:"cumsum[j+1] - cumsum[i]"}),"."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)(a,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class NumArray {\n   public:\n    NumArray(vector<int> nums) : cumsum_(nums.size() + 1, 0) {\n        partial_sum(nums.begin(), nums.end(), cumsum_.begin() + 1);\n    }\n\n    int sumRange(int left, int right) {\n        return cumsum_[right + 1] - cumsum_[left];\n    }\n\n   private:\n    vector<int> cumsum_;\n};\n"})})}),(0,t.jsx)(a,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class NumArray:\n    def __init__(self, nums: List[int]):\n        self.cumsum = [0] + nums[:]\n        for i in range(2, len(self.cumsum)):\n            self.cumsum[i] += self.cumsum[i - 1]\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.cumsum[right + 1] - self.cumsum[left]\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"304-range-sum-query-2d---immutable",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/range-sum-query-2d-immutable/",children:"304. Range Sum Query 2D - Immutable"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,t.jsx)(n.p,{children:"Design a data structure to quickly query the sum of all numbers within a rectangle defined by any two positions in a given matrix."}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,t.jsxs)(n.p,{children:["Here is a sample usage of the data structure. The ",(0,t.jsx)(n.code,{children:"sumRegion"})," function takes four inputs: the row and column of the first point, and the row and column of the second point."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"vector<int> matrix{{3,0,1,4,2},\n {5,6,3,2,1},\n {1,2,0,1,5},\n {4,1,0,1,7},\n {1,0,3,0,5}\n};\nNumMatrix num_matrix = new NumMatrix(matrix);\nnum_matrix.sumRegion(2,1,4,3); // Result = 8.\nnum_matrix.sumRegion(1,1,2,2); // Result = 11.\n"})}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["Similar to prefix sums, we can extend this concept to two dimensions, known as a summed-area table (SAT) or image integral. We can first build an ",(0,t.jsx)(n.code,{children:"sat"})," matrix, where ",(0,t.jsx)(n.code,{children:"sat[i][j]"})," represents the sum of all numbers in the rectangle defined by ",(0,t.jsx)(n.code,{children:"(0, 0)"})," as the top-left corner and ",(0,t.jsx)(n.code,{children:"(i-1, j-1)"})," as the bottom-right corner."]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("span",{style:{display:"block",width:"60%",margin:"0 auto"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:s(8512).A+"",width:"823",height:"423"})})}),(0,t.jsx)("figcaption",{style:{textAlign:"center"},children:"Figure 10.4: Problem 304 - Diagram 1 - The left shows the given matrix, and the right shows the summed-area table. The value at the bottom-right corner of the SAT is 5+48+45\u221240 = 58."})]}),"\n",(0,t.jsxs)("figure",{children:[(0,t.jsx)("span",{style:{display:"block",width:"60%",margin:"0 auto"},children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:s(2713).A+"",width:"834",height:"424"})})}),(0,t.jsx)("figcaption",{style:{textAlign:"center"},children:"Figure 10.5: Problem 304 - Diagram 2 - The left shows the given matrix, and the right shows the SAT. The sum of rectangle E equals 58 \u2212 11 \u2212 13 + 3 = 37."})]}),"\n",(0,t.jsxs)(n.p,{children:["As shown in Figure 1, we can compute the ",(0,t.jsx)(n.code,{children:"sat"})," matrix using dynamic programming: ",(0,t.jsx)(n.code,{children:"sat[i][j] = matrix[i-1][j-1] + sat[i-1][j] + sat[i][j-1] - sat[i-1][j-1]"}),", which is the value at the current coordinate plus the sum of the rectangle above it plus the sum of the rectangle to its left minus the overlap (i.e., the top-left rectangle)."]}),"\n",(0,t.jsxs)(n.p,{children:["As shown in Figure 2, suppose we need to query the sum of rectangle E. Since ",(0,t.jsx)(n.code,{children:"E = D \u2212 B \u2212 C + A"}),", we observe that E can be derived using addition and subtraction of SAT values at four positions. Thus, the preprocessing time complexity is ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mi,{children:"m"}),(0,t.jsx)(n.mi,{children:"n"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(mn)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"mn"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]}),", while the query time complexity is only ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"O"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"("}),(0,t.jsx)(n.mn,{children:"1"}),(0,t.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(n.span,{className:"mopen",children:"("}),(0,t.jsx)(n.span,{className:"mord",children:"1"}),(0,t.jsx)(n.span,{className:"mclose",children:")"})]})})]}),"."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)(a,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"class NumMatrix {\n   public:\n    NumMatrix(vector<vector<int>> matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        sat_ = vector<vector<int>>(m + 1, vector<int>(n + 1, 0));\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                sat_[i][j] = matrix[i - 1][j - 1] + sat_[i - 1][j] +\n                             sat_[i][j - 1] - sat_[i - 1][j - 1];\n            }\n        }\n    }\n\n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return sat_[row2 + 1][col2 + 1] - sat_[row2 + 1][col1] -\n               sat_[row1][col2 + 1] + sat_[row1][col1];\n    }\n\n   private:\n    vector<vector<int>> sat_;\n};\n"})})}),(0,t.jsx)(a,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"class NumMatrix:\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        self.sat = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sat[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sat[i - 1][j]\n                    + self.sat[i][j - 1]\n                    - self.sat[i - 1][j - 1]\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return (\n            self.sat[row2 + 1][col2 + 1]\n            - self.sat[row2 + 1][col1]\n            - self.sat[row1][col2 + 1]\n            + self.sat[row1][col1]\n        )\n\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"560-subarray-sum-equals-k",children:(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/subarray-sum-equals-k/",children:"560. Subarray Sum Equals K"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,t.jsxs)(n.p,{children:["Given an array, find the number of continuous subarrays whose sum equals ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"k"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"k"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"})]})})]}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,t.jsxs)(n.p,{children:["Input is a one-dimensional integer array and an integer value ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"k"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"k"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"})]})})]}),"; output is an integer representing the number of subarrays that meet the condition."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Input: nums = [1,1,1], k = 2\nOutput: 2\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this example, we can find two subarrays [1,1] that satisfy the condition."}),"\n",(0,t.jsx)(n.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["This problem also uses prefix sums. The difference here is that we employ a hash table ",(0,t.jsx)(n.code,{children:"cache"})," where the keys are prefix sums and the values are the number of times that prefix sum appears. When iterating to position ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"i"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"})]})})]}),", if the current prefix sum is ",(0,t.jsx)(n.code,{children:"cumsum"}),", then ",(0,t.jsx)(n.code,{children:"cache[cumsum-k]"})," represents the number of subarrays ending at the current position that satisfy the condition."]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)(a,{value:"cpp",label:"C++",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"int subarraySum(vector<int>& nums, int k) {\n    int count = 0, cumsum = 0;\n    unordered_map<int, int> cache;  // <cumsum, frequency>\n    cache[0] = 1;\n    for (int num : nums) {\n        cumsum += num;\n        count += cache[cumsum - k];\n        ++cache[cumsum];\n    }\n    return count;\n}\n"})})}),(0,t.jsx)(a,{value:"py",label:"Python",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:"def subarraySum(nums: List[int], k: int) -> int:\n    count, cur_sum = 0, 0\n    cache = {0: 1} # <cumsum, frequency>\n    for num in nums:\n        cur_sum += num\n        count += cache.get(cur_sum - k, 0)\n        cache[cur_sum] = cache.get(cur_sum, 0) + 1\n    return count\n"})})})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}function d(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8512:(e,n,s)=>{s.d(n,{A:()=>a});const a=s.p+"assets/images/10.4-859c47a25a3275dfd5bdd76b3fc6eff1.png"},2713:(e,n,s)=>{s.d(n,{A:()=>a});const a=s.p+"assets/images/10.5-bbec878fb3af2fc04d0d9ccb78a57761.png"}}]);