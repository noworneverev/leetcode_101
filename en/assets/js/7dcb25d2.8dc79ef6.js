"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[2652],{4934:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"linked-lists/12-1-data-structure-introduction","title":"12.1 Data Structure Introduction","description":"A (singly) linked list is a data structure composed of nodes and pointers. Each node contains a value and a pointer to the next node. As a result, many linked list problems can be solved using recursion. Unlike arrays, a linked list cannot directly access the value of any node; it must traverse through pointers to reach the desired node. Similarly, the length of a linked list cannot be determined unless it is fully traversed or tracked using another data structure. LeetCode\u2019s default representation of a linked list is as follows.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/12-linked-lists/12-1-data-structure-introduction.md","sourceDirName":"12-linked-lists","slug":"/linked-lists/12-1-data-structure-introduction","permalink":"/leetcode_101/en/linked-lists/12-1-data-structure-introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/12-linked-lists/12-1-data-structure-introduction.md","tags":[],"version":"current","sidebarPosition":64,"frontMatter":{"sidebar_position":64},"sidebar":"tutorialSidebar","previous":{"title":"12. \u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e00\uff1a\u94fe\u8868","permalink":"/leetcode_101/en/category/12-\u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e00\u94fe\u8868"},"next":{"title":"12.2 Basic Operations on Linked Lists","permalink":"/leetcode_101/en/linked-lists/12-2-basic-linked-list-operations"}}');var s=n(4848),r=n(8453);const o={sidebar_position:64},a="12.1 Data Structure Introduction",l={},d=[];function c(e){const t={admonition:"admonition",code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components},{TabItem:n,Tabs:i}=t;return n||h("TabItem",!0),i||h("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"121-data-structure-introduction",children:"12.1 Data Structure Introduction"})}),"\n",(0,s.jsxs)(t.p,{children:["A (singly) ",(0,s.jsx)(t.code,{children:"linked list"})," is a data structure composed of nodes and pointers. Each node contains a value and a pointer to the next node. As a result, many linked list problems can be solved using recursion. Unlike arrays, a linked list cannot directly access the value of any node; it must traverse through pointers to reach the desired node. Similarly, the length of a linked list cannot be determined unless it is fully traversed or tracked using another data structure. LeetCode\u2019s default representation of a linked list is as follows."]}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsx)(n,{value:"cpp",label:"C++",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n"})})}),(0,s.jsx)(n,{value:"py",label:"Python",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-py",children:"class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None # or a ListNode\n"})})})]}),"\n",(0,s.jsx)(t.p,{children:"When performing operations on a linked list, especially when deleting nodes, issues with memory or pointers often arise due to directly modifying the current node. Two techniques can help mitigate these problems:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Try to operate on the next node rather than the current node itself."}),"\n",(0,s.jsxs)(t.li,{children:["Create a dummy node that points to the head of the current linked list. This ensures that even if all nodes in the original list are deleted, the dummy node persists, and you can safely return ",(0,s.jsx)(t.code,{children:"dummy->next"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"In most algorithm problems, explicit memory deletion is unnecessary. When solving LeetCode problems, you can simply adjust pointers without deallocating memory. However, in real-world software engineering, it is recommended to explicitly free unused memory or use smart pointers to manage it efficiently."})})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function h(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);