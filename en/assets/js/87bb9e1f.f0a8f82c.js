"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[4643],{2514:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"dynamic-programming/6-3-basic-dp-2d","title":"6.3 Basic Dynamic Programming: Two-Dimensional","description":"64. Minimum Path Sum","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/6-dynamic-programming/6-3-basic-dp-2d.mdx","sourceDirName":"6-dynamic-programming","slug":"/dynamic-programming/6-3-basic-dp-2d","permalink":"/leetcode_101/en/dynamic-programming/6-3-basic-dp-2d","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":28,"frontMatter":{"sidebar_position":28},"sidebar":"tutorialSidebar","previous":{"title":"6.2 Basic Dynamic Programming: One-Dimensional","permalink":"/leetcode_101/en/dynamic-programming/6-2-basic-dp-1d"},"next":{"title":"6.4 Partition Type Problems","permalink":"/leetcode_101/en/dynamic-programming/6-4-partition-problems"}}');var a=i(4848),t=i(8453);const r={sidebar_position:28},l="6.3 Basic Dynamic Programming: Two-Dimensional",d={},m=[{value:"64. Minimum Path Sum",id:"64-minimum-path-sum",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"542. 01 Matrix",id:"542-01-matrix",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"221. Maximal Square",id:"221-maximal-square",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3}];function o(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,t.R)(),...e.components},{TabItem:s,Tabs:r}=n;return s||h("TabItem",!0),r||h("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"63-basic-dynamic-programming-two-dimensional",children:"6.3 Basic Dynamic Programming: Two-Dimensional"})}),"\n",(0,a.jsx)(n.h2,{id:"64-minimum-path-sum",children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/minimum-path-sum/",children:"64. Minimum Path Sum"})}),"\n",(0,a.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,a.jsxs)(n.p,{children:["Given an ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"m"}),(0,a.jsx)(n.mo,{children:"\xd7"}),(0,a.jsx)(n.mi,{children:"n"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"m \xd7 n"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"m"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})]})]})," non-negative integer matrix, find the path from the top-left to the bottom-right corner with the smallest sum of numbers. You can only move right or down."]}),"\n",(0,a.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,a.jsx)(n.p,{children:"Input is a two-dimensional array, and output is the sum of the numbers along the optimal path."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input:\n[[1,3,1],\n [1,5,1],\n [4,2,1]]\nOutput: 7\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this example, the shortest path is 1->3->1->1->1."}),"\n",(0,a.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,a.jsxs)(n.p,{children:["We can define a ",(0,a.jsx)(n.code,{children:"dp"})," array of the same dimensions, where ",(0,a.jsx)(n.code,{children:"dp[i][j]"})," represents the sum of numbers along the optimal path from the top-left corner to position ",(0,a.jsx)(n.code,{children:"(i, j)"}),". Since you can only move down or right, the state transition equation is ",(0,a.jsx)(n.code,{children:"dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])"}),", where ",(0,a.jsx)(n.code,{children:"grid"})," represents the original matrix."]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["In Python, initializing multi-dimensional arrays requires caution. Direct initialization using ",(0,a.jsx)(n.code,{children:"[[val] * n] * m"})," creates ",(0,a.jsx)(n.code,{children:"m"})," references to the same ",(0,a.jsx)(n.code,{children:"[[val] * n]"})," object. The correct initialization method is ",(0,a.jsx)(n.code,{children:"[[val for _ in range(n)] for _ in range(m)]"}),"."]})}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)(s,{value:"cpp",label:"C++",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    vector<vector<int>> dp(m, vector<int>(n, 0));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] = grid[i][j] + dp[i][j - 1];\n            } else if (j == 0) {\n                dp[i][j] = grid[i][j] + dp[i - 1][j];\n            } else {\n                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n"})})}),(0,a.jsx)(s,{value:"py",label:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"def minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == j == 0:\n                dp[i][j] = grid[i][j]\n            elif i == 0:\n                dp[i][j] = grid[i][j] + dp[i][j - 1]\n            elif j == 0:\n                dp[i][j] = grid[i][j] + dp[i - 1][j]\n            else:\n                dp[i][j] = grid[i][j] + min(dp[i][j - 1], dp[i - 1][j])\n    return dp[m - 1][n - 1]\n"})})})]}),"\n",(0,a.jsxs)(n.p,{children:["Since each value in the ",(0,a.jsx)(n.code,{children:"dp"})," matrix depends only on the values to its left and above, we can apply space optimization to reduce the ",(0,a.jsx)(n.code,{children:"dp"})," array to one dimension. For the ",(0,a.jsx)(n.code,{children:"i-th"})," row, when iterating to the ",(0,a.jsx)(n.code,{children:"j-th"})," column, since the ",(0,a.jsx)(n.code,{children:"j-1-th"})," column has already been updated, ",(0,a.jsx)(n.code,{children:"dp[j-1]"})," represents the value of ",(0,a.jsx)(n.code,{children:"dp[i][j-1]"}),". Meanwhile, ",(0,a.jsx)(n.code,{children:"dp[j]"})," is yet to be updated, and the current stored value represents the value of ",(0,a.jsx)(n.code,{children:"dp[i-1][j]"})," from the previous row."]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"If you are not very familiar with space optimization techniques, it is recommended to first write a solution without space optimization. Apply space optimization only if time permits and you are comfortable with the approach."})}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)(s,{value:"cpp",label:"C++",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    vector<int> dp(n, 0);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == 0 && j == 0) {\n                dp[j] = grid[i][j];\n            } else if (i == 0) {\n                dp[j] = grid[i][j] + dp[j - 1];\n            } else if (j == 0) {\n                dp[j] = grid[i][j] + dp[j];\n            } else {\n                dp[j] = grid[i][j] + min(dp[j], dp[j - 1]);\n            }\n        }\n    }\n    return dp[n - 1];\n}\n"})})}),(0,a.jsx)(s,{value:"py",label:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"def minPathSum(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [0 for _ in range(n)]\n    for i in range(m):\n        for j in range(n):\n        if i == j == 0:\n            dp[j] = grid[i][j]\n        elif i == 0:\n            dp[j] = grid[i][j] + dp[j - 1]\n        elif j == 0:\n            dp[j] = grid[i][j] + dp[j]\n        else:\n            dp[j] = grid[i][j] + min(dp[j - 1], dp[j])\n    return dp[n - 1]\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"542-01-matrix",children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/01-matrix/",children:"542. 01 Matrix"})}),"\n",(0,a.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,a.jsx)(n.p,{children:"Given a 2D matrix consisting of 0s and 1s, find the distance of each position to the nearest 0."}),"\n",(0,a.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,a.jsx)(n.p,{children:"The input is a 2D 0-1 array, and the output is a 2D non-negative integer array of the same size, representing the distance of each position to the nearest 0."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Input:\n[[0,0,0],\n [0,1,0],\n [1,1,1]]\n\nOutput:\n[[0,0,0],\n [0,1,0],\n [1,2,1]]\n"})}),"\n",(0,a.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,a.jsxs)(n.p,{children:["Typically, as this problem involves finding the nearest position in four directions, many people might initially consider breadth-first search (BFS). However, for a 2D array of size ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"m"}),(0,a.jsx)(n.mi,{children:"n"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(mn)"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"mn"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})})]}),", performing four-directional BFS for each position results in a worst-case time complexity of ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsxs)(n.msup,{children:[(0,a.jsx)(n.mi,{children:"m"}),(0,a.jsx)(n.mn,{children:"2"})]}),(0,a.jsxs)(n.msup,{children:[(0,a.jsx)(n.mi,{children:"n"}),(0,a.jsx)(n.mn,{children:"2"})]}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(m^2n^2)"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",children:"m"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsx)(n.span,{className:"vlist-t",children:(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,a.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsx)(n.span,{className:"vlist-t",children:(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,a.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})})]})," (when all entries are 1)."]}),"\n",(0,a.jsx)(n.p,{children:"One approach is to use a 2D boolean array for memoization, ensuring that BFS does not revisit the same position. A simpler approach, however, is to perform a dynamic search from the top-left to the bottom-right, followed by another dynamic search from the bottom-right to the top-left. These two searches efficiently account for all four directions."}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)(s,{value:"cpp",label:"C++",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    vector<vector<int>> dp(m, vector<int>(n, numeric_limits<int>::max() - 1));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (matrix[i][j] != 0) {\n                if (i > 0) {\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);\n                }\n                if (j > 0) {\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);\n                }\n            } else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = n - 1; j >= 0; --j) {\n            if (matrix[i][j] != 0) {\n                if (i < m - 1) {\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1);\n                }\n                if (j < n - 1) {\n                    dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);\n                }\n            }\n        }\n    }\n    return dp;\n}\n"})})}),(0,a.jsx)(s,{value:"py",label:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:"def updateMatrix(matrix: List[List[int]]) -> List[List[int]]:\n    m, n = len(matrix), len(matrix[0])\n    dp = [[sys.maxsize - 1 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] != 0:\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n            else:\n                dp[i][j] = 0\n    for i in range(m - 1, -1, -1): # m-1 to 0, reversed\n        for j in range(n - 1, -1, -1): # n-1 to 0, reversed\n            if matrix[i][j] != 0:\n                if i < m - 1:\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1)\n                if j < n - 1:\n                    dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1)\n        return dp\n"})})})]}),"\n",(0,a.jsx)(n.h2,{id:"221-maximal-square",children:(0,a.jsx)(n.a,{href:"https://leetcode.com/problems/maximal-square/",children:"221. Maximal Square"})}),"\n",(0,a.jsx)(n.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,a.jsx)(n.p,{children:"Given a 2D binary matrix filled with 0s and 1s, find the largest square containing only 1s and return its area."}),"\n",(0,a.jsx)(n.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,a.jsx)(n.p,{children:"The input is a 2D binary matrix, and the output is the area of the largest square."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'Input:\n[["1","0","1","0","0"],\n ["1","0","1","1","1"],\n ["1","1","1","1","1"],\n ["1","0","0","1","0"]]\nOutput: 4\n'})}),"\n",(0,a.jsx)(n.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,a.jsxs)(n.p,{children:["For problems involving finding squares or rectangles in a matrix, a common approach is to define a 2D dp array, where dp[i][j] represents the attribute of the square or rectangle that meets the problem's requirements with (i, j) as the bottom-right corner. In this problem, dp[i][j] represents the side length of the largest square containing only 1s with (i, j) as the bottom-right corner. If the current position is 0, then dp[i][j] = 0. If the current position is 1, assuming dp[i][j] = k, the necessary condition is that dp[i-1][j-1], dp[i][j-1], and dp[i-1][j] must all be at least k \u2212 1; otherwise, (i, j) cannot form a square of area ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msup,{children:[(0,a.jsx)(n.mi,{children:"k"}),(0,a.jsx)(n.mn,{children:"2"})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"k^2"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.8141em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsx)(n.span,{className:"vlist-t",children:(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,a.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]})]})})]}),". Conversely, if the minimum of these three values is k \u2212 1, then (i, j) can and will form a square of area ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsxs)(n.msup,{children:[(0,a.jsx)(n.mi,{children:"k"}),(0,a.jsx)(n.mn,{children:"2"})]})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"k^2"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.8141em"}}),(0,a.jsxs)(n.span,{className:"mord",children:[(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsx)(n.span,{className:"vlist-t",children:(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,a.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"2"})})]})})})})})]})]})})]}),"."]}),"\n",(0,a.jsxs)("figure",{children:[(0,a.jsx)("span",{style:{display:"block",width:"75%",margin:"0 auto"},children:(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:i(4005).A+"",width:"893",height:"458"})})}),(0,a.jsx)("figcaption",{style:{textAlign:"center"},children:"Figure 6.1: Problem 221 - The left shows a 0-1 matrix, and the right shows its corresponding dp matrix. The largest square has a side length of 3"})]}),"\n",(0,a.jsxs)(r,{children:[(0,a.jsx)(s,{value:"cpp",label:"C++",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int maximalSquare(vector<vector<char>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    int max_side = 0;\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (matrix[i - 1][j - 1] == \u20191\u2019) {\n                dp[i][j] =\n                    min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;\n            }\n            max_side = max(max_side, dp[i][j]);\n        }\n    }\n    return max_side * max_side;\n}\n"})})}),(0,a.jsx)(s,{value:"py",label:"Python",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-py",children:'def maximalSquare(matrix: List[List[str]]) -> int:\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == "1":\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1\n    return max(max(row) for row in dp) ** 2\n'})})})]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},4005:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/6.1-16d67775d91bdad7a65403ffa5026ab7.png"}}]);