"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[3965],{7959:(s,e,n)=>{n.r(e),n.d(e,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"sorting-algorithms/4-1-common-sorting-algorithms","title":"4.1 Common Sorting Algorithms","description":"Although sorting can be achieved in C++ and Python using the sort function and it is rare to write sorting algorithms manually during coding challenges, understanding various sorting algorithms helps deepen your knowledge of basic algorithms and solve problems derived from these algorithms. Here, we introduce two sorting algorithms with a time complexity of $O(n \\\\log n)$: Quick Sort and Merge Sort. The former is generally faster, while the latter ensures that elements with the same value maintain their relative order in the array (i.e., it is a \\"stable sort\\").","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/4-sorting-algorithms/4-1-common-sorting-algorithms.mdx","sourceDirName":"4-sorting-algorithms","slug":"/sorting-algorithms/4-1-common-sorting-algorithms","permalink":"/leetcode_101/en/sorting-algorithms/4-1-common-sorting-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/4-sorting-algorithms/4-1-common-sorting-algorithms.mdx","tags":[],"version":"current","sidebarPosition":17,"frontMatter":{"sidebar_position":17},"sidebar":"tutorialSidebar","previous":{"title":"4. \u5343\u5947\u767e\u602a\u7684\u6392\u5e8f\u7b97\u6cd5","permalink":"/leetcode_101/en/category/4-\u5343\u5947\u767e\u602a\u7684\u6392\u5e8f\u7b97\u6cd5"},"next":{"title":"4.2 Quick Select","permalink":"/leetcode_101/en/sorting-algorithms/4-2-quick-select"}}');var i=n(4848),t=n(8453);const r={sidebar_position:17},l="4.1 Common Sorting Algorithms",m={},c=[{value:"Quicksort",id:"quicksort",level:2},{value:"Merge Sort",id:"merge-sort",level:2}];function o(s){const e={annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,t.R)(),...s.components},{TabItem:n,Tabs:a}=e;return n||d("TabItem",!0),a||d("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"41-common-sorting-algorithms",children:"4.1 Common Sorting Algorithms"})}),"\n",(0,i.jsxs)(e.p,{children:["Although sorting can be achieved in C++ and Python using the ",(0,i.jsx)(e.code,{children:"sort"})," function and it is rare to write sorting algorithms manually during coding challenges, understanding various sorting algorithms helps deepen your knowledge of basic algorithms and solve problems derived from these algorithms. Here, we introduce two sorting algorithms with a time complexity of ",(0,i.jsxs)(e.span,{className:"katex",children:[(0,i.jsx)(e.span,{className:"katex-mathml",children:(0,i.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(e.semantics,{children:[(0,i.jsxs)(e.mrow,{children:[(0,i.jsx)(e.mi,{children:"O"}),(0,i.jsx)(e.mo,{stretchy:"false",children:"("}),(0,i.jsx)(e.mi,{children:"n"}),(0,i.jsx)(e.mi,{children:"log"}),(0,i.jsx)(e.mo,{children:"\u2061"}),(0,i.jsx)(e.mi,{children:"n"}),(0,i.jsx)(e.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(e.annotation,{encoding:"application/x-tex",children:"O(n \\log n)"})]})})}),(0,i.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(e.span,{className:"mopen",children:"("}),(0,i.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsxs)(e.span,{className:"mop",children:["lo",(0,i.jsx)(e.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(e.span,{className:"mclose",children:")"})]})})]}),": ",(0,i.jsx)(e.code,{children:"Quick Sort"})," and ",(0,i.jsx)(e.code,{children:"Merge Sort"}),'. The former is generally faster, while the latter ensures that elements with the same value maintain their relative order in the array (i.e., it is a "stable sort").']}),"\n",(0,i.jsx)(e.h2,{id:"quicksort",children:"Quicksort"}),"\n",(0,i.jsxs)(e.p,{children:["The principle of Quick Sort is straightforward: for an unsorted segment, we randomly choose a position as the pivot and rearrange the elements such that all numbers smaller than the pivot are moved to its left and all numbers larger than the pivot are moved to its right. After this operation, we recursively perform Quick Sort on the segments to the left and right of the pivot. It can be proven that if the pivot is chosen randomly, the average complexity of this algorithm is ",(0,i.jsxs)(e.span,{className:"katex",children:[(0,i.jsx)(e.span,{className:"katex-mathml",children:(0,i.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(e.semantics,{children:[(0,i.jsxs)(e.mrow,{children:[(0,i.jsx)(e.mi,{children:"O"}),(0,i.jsx)(e.mo,{stretchy:"false",children:"("}),(0,i.jsx)(e.mi,{children:"n"}),(0,i.jsx)(e.mi,{children:"log"}),(0,i.jsx)(e.mo,{children:"\u2061"}),(0,i.jsx)(e.mi,{children:"n"}),(0,i.jsx)(e.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(e.annotation,{encoding:"application/x-tex",children:"O(n \\log n)"})]})})}),(0,i.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(e.span,{className:"mopen",children:"("}),(0,i.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsxs)(e.span,{className:"mop",children:["lo",(0,i.jsx)(e.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(e.span,{className:"mclose",children:")"})]})})]}),", while the worst-case complexity is ",(0,i.jsxs)(e.span,{className:"katex",children:[(0,i.jsx)(e.span,{className:"katex-mathml",children:(0,i.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(e.semantics,{children:[(0,i.jsxs)(e.mrow,{children:[(0,i.jsx)(e.mi,{children:"O"}),(0,i.jsx)(e.mo,{stretchy:"false",children:"("}),(0,i.jsxs)(e.msup,{children:[(0,i.jsx)(e.mi,{children:"n"}),(0,i.jsx)(e.mn,{children:"2"})]}),(0,i.jsx)(e.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(e.annotation,{encoding:"application/x-tex",children:"O(n^2)"})]})})}),(0,i.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(e.span,{className:"mopen",children:"("}),(0,i.jsxs)(e.span,{className:"mord",children:[(0,i.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(e.span,{className:"msupsub",children:(0,i.jsx)(e.span,{className:"vlist-t",children:(0,i.jsx)(e.span,{className:"vlist-r",children:(0,i.jsx)(e.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(e.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(e.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(e.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(e.span,{className:"mord mtight",children:"2"})})]})})})})})]}),(0,i.jsx)(e.span,{className:"mclose",children:")"})]})})]}),"."]}),"\n",(0,i.jsxs)(e.p,{children:["We use a left-closed, right-closed interval approach, initializing with ",(0,i.jsxs)(e.span,{className:"katex",children:[(0,i.jsx)(e.span,{className:"katex-mathml",children:(0,i.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(e.semantics,{children:[(0,i.jsxs)(e.mrow,{children:[(0,i.jsx)(e.mi,{children:"l"}),(0,i.jsx)(e.mo,{children:"="}),(0,i.jsx)(e.mn,{children:"0"}),(0,i.jsx)(e.mo,{separator:"true",children:","}),(0,i.jsx)(e.mi,{children:"r"}),(0,i.jsx)(e.mo,{children:"="}),(0,i.jsx)(e.mi,{children:"n"}),(0,i.jsx)(e.mo,{children:"\u2212"}),(0,i.jsx)(e.mn,{children:"1"})]}),(0,i.jsx)(e.annotation,{encoding:"application/x-tex",children:"l = 0, r = n - 1"})]})})}),(0,i.jsxs)(e.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"0.6944em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(e.span,{className:"mrel",children:"="}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"0.8389em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(e.span,{className:"mord",children:"0"}),(0,i.jsx)(e.span,{className:"mpunct",children:","}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"r"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(e.span,{className:"mrel",children:"="}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(e.span,{className:"mbin",children:"\u2212"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(e.span,{className:"mord",children:"1"})]})]})]}),"."]}),"\n",(0,i.jsxs)(a,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"void quickSort(vector<int> &nums, int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    // Randomly choose a pivot within the current [l, r] interval.\n    int pivot = l + (rand() % (r - l + 1));\n    int pivot_val = nums[pivot];\n    // Swap the pivot with the first element.\n    swap(nums[l], nums[pivot]);\n    // Traverse inward from both ends of [l+1, r] to find misplaced elements.\n    int i = l + 1, j = r;\n    while (true) {\n        while (i < j && nums[j] >= pivot_val) {\n            --j;\n        }\n        while (i < j && nums[i] <= pivot_val) {\n            ++i;\n        }\n        if (i == j) {\n            break;\n        }\n        // Swap the misplaced elements.\n        swap(nums[i], nums[j]);\n    }\n    // Swap the pivot back to its correct position.\n    int new_pivot = nums[i] <= nums[l] ? i : i - 1;\n    swap(nums[l], nums[new_pivot]);\n    quickSort(nums, l, new_pivot - 1);\n    quickSort(nums, new_pivot + 1, r);\n}\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-py",children:"def quickSort(nums: List[int], l: int, r: int) -> None:\n    if l >= r:\n        return\n    # Randomly choose a pivot within the current [l, r] interval.\n    pivot = random.randint(l, r)\n    pivot_val = nums[pivot]\n    # Swap the pivot with the first element.\n    nums[l], nums[pivot] = nums[pivot], nums[l]\n    # Traverse inward from both ends of [l+1, r] to find misplaced elements.\n    i, j = l + 1, r\n    while True:\n        while i < j and nums[j] >= pivot_val:\n            j -= 1\n        while i < j and nums[i] <= pivot_val:\n            i += 1\n        if i == j:\n            break\n        # Swap the misplaced elements.\n        nums[i], nums[j] = nums[j], nums[i]\n    # Swap the pivot back to its correct position.\n    new_pivot = i if nums[i] <= nums[l] else i - 1\n    nums[l], nums[new_pivot] = nums[new_pivot], nums[l]\n    quickSort(nums, l, new_pivot - 1)\n    quickSort(nums, new_pivot + 1, r)\n"})})})]}),"\n",(0,i.jsx)(e.h2,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,i.jsx)(e.p,{children:'Merge Sort is a classic divide-and-conquer algorithm, which we will elaborate on in later sections. In short, for an unsorted segment, we first sort its left and right halves separately and then merge the two halves ("conquer"). Sorting each half can be achieved recursively by further splitting each half into two parts ("divide").'}),"\n",(0,i.jsxs)(e.p,{children:["We use a left-closed, right-closed interval approach, initializing with ",(0,i.jsxs)(e.span,{className:"katex",children:[(0,i.jsx)(e.span,{className:"katex-mathml",children:(0,i.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(e.semantics,{children:[(0,i.jsxs)(e.mrow,{children:[(0,i.jsx)(e.mi,{children:"l"}),(0,i.jsx)(e.mo,{children:"="}),(0,i.jsx)(e.mn,{children:"0"}),(0,i.jsx)(e.mo,{separator:"true",children:","}),(0,i.jsx)(e.mi,{children:"r"}),(0,i.jsx)(e.mo,{children:"="}),(0,i.jsx)(e.mi,{children:"n"}),(0,i.jsx)(e.mo,{children:"\u2212"}),(0,i.jsx)(e.mn,{children:"1"})]}),(0,i.jsx)(e.annotation,{encoding:"application/x-tex",children:"l = 0, r = n - 1"})]})})}),(0,i.jsxs)(e.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"0.6944em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(e.span,{className:"mrel",children:"="}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"0.8389em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(e.span,{className:"mord",children:"0"}),(0,i.jsx)(e.span,{className:"mpunct",children:","}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"r"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(e.span,{className:"mrel",children:"="}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"0.6667em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(e.span,{className:"mbin",children:"\u2212"}),(0,i.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(e.span,{className:"mord",children:"1"})]})]})]}),", and pre-allocate an array cache of the same size as nums to store intermediate results."]}),"\n",(0,i.jsxs)(a,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"void mergeSort(vector<int> &nums, vector<int> &cache, int l, int r) {\n    if (l >= r) {\n        return;\n    }\n    // Divide.\n    int mid = l + (r - l) / 2;\n    mergeSort(nums, cache, l, mid);\n    mergeSort(nums, cache, mid + 1, r);\n    // Conquer.\n    // Use two pointers, i and j, to traverse the left [l, mid] and right [mid+1, r] halves.\n    int i = l, j = mid + 1;\n    for (int pos = l; pos <= r; ++pos) {\n        if (j > r || (i <= mid && nums[i] <= nums[j])) {\n            cache[pos] = nums[i++];\n        } else {\n            cache[pos] = nums[j++];\n        }\n    }\n    // Copy the sorted elements back to nums.\n    for (int pos = l; pos <= r; ++pos) {\n        nums[pos] = cache[pos];\n    }\n}\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-py",children:"def mergeSort(nums: List[int], cache: List[int], l: int, r: int) -> None:\n    if l >= r:\n        return\n    # Divide.\n    mid = (l + r) // 2\n    mergeSort(nums, cache, l, mid)\n    mergeSort(nums, cache, mid + 1, r)\n    # Conquer.\n    # Use two pointers, i and j, to traverse the left [l, mid] and right [mid+1, r] halves.\n    i, j = l, mid + 1\n    for pos in range(l, r + 1):\n        if j > r or (i <= mid and nums[i] <= nums[j]):\n            cache[pos] = nums[i]\n            i += 1\n        else:\n            cache[pos] = nums[j]\n            j += 1\n    # Copy the sorted elements back to nums.\n    nums[l:r+1] = cache[l:r+1]\n"})})})]})]})}function h(s={}){const{wrapper:e}={...(0,t.R)(),...s.components};return e?(0,i.jsx)(e,{...s,children:(0,i.jsx)(o,{...s})}):o(s)}function d(s,e){throw new Error("Expected "+(e?"component":"object")+" `"+s+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);