"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[6375],{3710:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"LeetCode 101: A Grinding Guide (2nd Edition)","href":"/leetcode_101/en/","docId":"index","unlisted":false},{"type":"category","label":"1. The Easiest Greedy Algorithm","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1.1 Algorithm Explanation","href":"/leetcode_101/en/greedy-algorithms/1-1-algorithm-explanation","docId":"greedy-algorithms/1-1-algorithm-explanation","unlisted":false},{"type":"link","label":"1.2 Distribution Problem","href":"/leetcode_101/en/greedy-algorithms/1-2-assignment-problems","docId":"greedy-algorithms/1-2-assignment-problems","unlisted":false},{"type":"link","label":"1.3 Interval Problem","href":"/leetcode_101/en/greedy-algorithms/1-3-interval-problems","docId":"greedy-algorithms/1-3-interval-problems","unlisted":false},{"type":"link","label":"1.4 Exercises","href":"/leetcode_101/en/greedy-algorithms/1-4-exercises","docId":"greedy-algorithms/1-4-exercises","unlisted":false}],"href":"/leetcode_101/en/category/1-\u6700\u6613\u61c2\u7684\u8d2a\u5fc3\u7b97\u6cd5"},{"type":"category","label":"2. Mastering Two Pointers","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"2.1 Algorithm Explanation","href":"/leetcode_101/en/two-pointer-techniques/2-1-algorithm-explanation","docId":"two-pointer-techniques/2-1-algorithm-explanation","unlisted":false},{"type":"link","label":"2.2 Two Sum","href":"/leetcode_101/en/two-pointer-techniques/2-2-two-sum","docId":"two-pointer-techniques/2-2-two-sum","unlisted":false},{"type":"link","label":"2.3 Merging Two Sorted Arrays","href":"/leetcode_101/en/two-pointer-techniques/2-3-merge-sorted-arrays","docId":"two-pointer-techniques/2-3-merge-sorted-arrays","unlisted":false},{"type":"link","label":"2.4 Sliding Window","href":"/leetcode_101/en/two-pointer-techniques/2-4-sliding-window","docId":"two-pointer-techniques/2-4-sliding-window","unlisted":false},{"type":"link","label":"2.5 Fast and Slow Pointers","href":"/leetcode_101/en/two-pointer-techniques/2-5-fast-slow-pointers","docId":"two-pointer-techniques/2-5-fast-slow-pointers","unlisted":false},{"type":"link","label":"2.6 Exercises","href":"/leetcode_101/en/two-pointer-techniques/2-6-exercises","docId":"two-pointer-techniques/2-6-exercises","unlisted":false}],"href":"/leetcode_101/en/category/2-\u73a9\u8f6c\u53cc\u6307\u9488"},{"type":"category","label":"3. Iaido! Binary Search","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"3.1 Algorithm Explanation","href":"/leetcode_101/en/binary-search-techniques/3-1-algorithm-explanation","docId":"binary-search-techniques/3-1-algorithm-explanation","unlisted":false},{"type":"link","label":"3.2 Calculating Square Root","href":"/leetcode_101/en/binary-search-techniques/3-2-square-root","docId":"binary-search-techniques/3-2-square-root","unlisted":false},{"type":"link","label":"3.3 Find Range","href":"/leetcode_101/en/binary-search-techniques/3-3-interval-search","docId":"binary-search-techniques/3-3-interval-search","unlisted":false},{"type":"link","label":"3.4 Find Maximum","href":"/leetcode_101/en/binary-search-techniques/3-4-peak-finding","docId":"binary-search-techniques/3-4-peak-finding","unlisted":false},{"type":"link","label":"3.5 Search in Rotated Array","href":"/leetcode_101/en/binary-search-techniques/3-5-rotated-array-search","docId":"binary-search-techniques/3-5-rotated-array-search","unlisted":false},{"type":"link","label":"3.6 Exercises","href":"/leetcode_101/en/binary-search-techniques/3-6-exercises","docId":"binary-search-techniques/3-6-exercises","unlisted":false}],"href":"/leetcode_101/en/category/3-\u5c45\u5408\u65a9\u4e8c\u5206\u67e5\u627e"},{"type":"category","label":"4. Peculiar Sorting Algorithms","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"4.1 Common Sorting Algorithms","href":"/leetcode_101/en/sorting-algorithms/4-1-common-sorting-algorithms","docId":"sorting-algorithms/4-1-common-sorting-algorithms","unlisted":false},{"type":"link","label":"4.2 Quick Select","href":"/leetcode_101/en/sorting-algorithms/4-2-quick-select","docId":"sorting-algorithms/4-2-quick-select","unlisted":false},{"type":"link","label":"4.3 Bucket Sort","href":"/leetcode_101/en/sorting-algorithms/4-3-bucket-sort","docId":"sorting-algorithms/4-3-bucket-sort","unlisted":false},{"type":"link","label":"4.4 Exercises","href":"/leetcode_101/en/sorting-algorithms/4-4-exercises","docId":"sorting-algorithms/4-4-exercises","unlisted":false}],"href":"/leetcode_101/en/category/4-\u5343\u5947\u767e\u602a\u7684\u6392\u5e8f\u7b97\u6cd5"},{"type":"category","label":"5. Everything is Searchable","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"5.1 Algorithm Explanation","href":"/leetcode_101/en/searching-algorithms/5-1-algorithm-explanation","docId":"searching-algorithms/5-1-algorithm-explanation","unlisted":false},{"type":"link","label":"5.2 Depth First Search","href":"/leetcode_101/en/searching-algorithms/5-2-depth-first-search","docId":"searching-algorithms/5-2-depth-first-search","unlisted":false},{"type":"link","label":"5.3 Backtracking","href":"/leetcode_101/en/searching-algorithms/5-3-backtracking","docId":"searching-algorithms/5-3-backtracking","unlisted":false},{"type":"link","label":"5.4 Breadth-First Search","href":"/leetcode_101/en/searching-algorithms/5-4-breadth-first-search","docId":"searching-algorithms/5-4-breadth-first-search","unlisted":false},{"type":"link","label":"5.5 Exercises","href":"/leetcode_101/en/searching-algorithms/5-5-exercises","docId":"searching-algorithms/5-5-exercises","unlisted":false}],"href":"/leetcode_101/en/category/5-\u4e00\u5207\u7686\u53ef\u641c\u7d22"},{"type":"category","label":"6. Dynamic Programming Made Simple","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"6.1 Algorithm Explanation","href":"/leetcode_101/en/dynamic-programming/6-1-algorithm-explanation","docId":"dynamic-programming/6-1-algorithm-explanation","unlisted":false},{"type":"link","label":"6.2 Basic Dynamic Programming: One-Dimensional","href":"/leetcode_101/en/dynamic-programming/6-2-basic-dp-1d","docId":"dynamic-programming/6-2-basic-dp-1d","unlisted":false},{"type":"link","label":"6.3 Basic Dynamic Programming: Two-Dimensional","href":"/leetcode_101/en/dynamic-programming/6-3-basic-dp-2d","docId":"dynamic-programming/6-3-basic-dp-2d","unlisted":false},{"type":"link","label":"6.4 Partition Type Problems","href":"/leetcode_101/en/dynamic-programming/6-4-partition-problems","docId":"dynamic-programming/6-4-partition-problems","unlisted":false},{"type":"link","label":"6.5 Subsequence Problem","href":"/leetcode_101/en/dynamic-programming/6-5-subsequence-problems","docId":"dynamic-programming/6-5-subsequence-problems","unlisted":false},{"type":"link","label":"6.6 Knapsack Problem","href":"/leetcode_101/en/dynamic-programming/6-6-knapsack-problem","docId":"dynamic-programming/6-6-knapsack-problem","unlisted":false},{"type":"link","label":"6.7 String Editing","href":"/leetcode_101/en/dynamic-programming/6-7-string-editing","docId":"dynamic-programming/6-7-string-editing","unlisted":false},{"type":"link","label":"6.8 Stock Trading","href":"/leetcode_101/en/dynamic-programming/6-8-stock-trading","docId":"dynamic-programming/6-8-stock-trading","unlisted":false},{"type":"link","label":"6.9 Exercises","href":"/leetcode_101/en/dynamic-programming/6-9-exercises","docId":"dynamic-programming/6-9-exercises","unlisted":false}],"href":"/leetcode_101/en/category/6-\u6df1\u5165\u6d45\u51fa\u52a8\u6001\u89c4\u5212"},{"type":"category","label":"7. Simplifying with Divide and Conquer","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"7.1 Algorithm Explanation","href":"/leetcode_101/en/divide-and-conquer/7-1-algorithm-explanation","docId":"divide-and-conquer/7-1-algorithm-explanation","unlisted":false},{"type":"link","label":"7.2 Expression Problems","href":"/leetcode_101/en/divide-and-conquer/7-2-expression-problems","docId":"divide-and-conquer/7-2-expression-problems","unlisted":false},{"type":"link","label":"7.3 Exercises","href":"/leetcode_101/en/divide-and-conquer/7-3-exercises","docId":"divide-and-conquer/7-3-exercises","unlisted":false}],"href":"/leetcode_101/en/category/7-\u5316\u7e41\u4e3a\u7b80\u7684\u5206\u6cbb\u6cd5"},{"type":"category","label":"8. Clever Math Problem Solving","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"8.1 Introduction","href":"/leetcode_101/en/mathematical-solutions/8-1-introduction","docId":"mathematical-solutions/8-1-introduction","unlisted":false},{"type":"link","label":"8.2 Least Common Multiple and Greatest Common Divisor","href":"/leetcode_101/en/mathematical-solutions/8-2-lcm-gcd","docId":"mathematical-solutions/8-2-lcm-gcd","unlisted":false},{"type":"link","label":"8.3 Prime Numbers","href":"/leetcode_101/en/mathematical-solutions/8-3-prime-numbers","docId":"mathematical-solutions/8-3-prime-numbers","unlisted":false},{"type":"link","label":"8.4 Numerical Processing","href":"/leetcode_101/en/mathematical-solutions/8-4-number-processing","docId":"mathematical-solutions/8-4-number-processing","unlisted":false},{"type":"link","label":"8.5 Random and Sampling","href":"/leetcode_101/en/mathematical-solutions/8-5-random-sampling","docId":"mathematical-solutions/8-5-random-sampling","unlisted":false},{"type":"link","label":"8.6 Exercises","href":"/leetcode_101/en/mathematical-solutions/8-6-exercises","docId":"mathematical-solutions/8-6-exercises","unlisted":false}],"href":"/leetcode_101/en/category/8-\u5de7\u89e3\u6570\u5b66\u95ee\u9898"},{"type":"category","label":"9. Magical Bit Manipulation","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"9.1 Common Techniques","href":"/leetcode_101/en/bitwise-operations/9-1-common-techniques","docId":"bitwise-operations/9-1-common-techniques","unlisted":false},{"type":"link","label":"9.2 Basic Problems in Bit Manipulation","href":"/leetcode_101/en/bitwise-operations/9-2-basic-bitwise-problems","docId":"bitwise-operations/9-2-basic-bitwise-problems","unlisted":false},{"type":"link","label":"9.3 Binary Features","href":"/leetcode_101/en/bitwise-operations/9-3-binary-properties","docId":"bitwise-operations/9-3-binary-properties","unlisted":false},{"type":"link","label":"9.4 Exercises","href":"/leetcode_101/en/bitwise-operations/9-4-exercises","docId":"bitwise-operations/9-4-exercises","unlisted":false}],"href":"/leetcode_101/en/category/9-\u795e\u5947\u7684\u4f4d\u8fd0\u7b97"},{"type":"category","label":"10. Ingenious Use of Data Structures","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"10.1 C++ STL","href":"/leetcode_101/en/data-structures/10-1-cpp-stl","docId":"data-structures/10-1-cpp-stl","unlisted":false},{"type":"link","label":"10.2 Python Common Data Structures","href":"/leetcode_101/en/data-structures/10-2-python-data-structures","docId":"data-structures/10-2-python-data-structures","unlisted":false},{"type":"link","label":"10.3 Arrays","href":"/leetcode_101/en/data-structures/10-3-arrays","docId":"data-structures/10-3-arrays","unlisted":false},{"type":"link","label":"10.4 Stacks and Queues","href":"/leetcode_101/en/data-structures/10-4-stack-and-queue","docId":"data-structures/10-4-stack-and-queue","unlisted":false},{"type":"link","label":"10.5 Monotonic Stack","href":"/leetcode_101/en/data-structures/10-5-monotonic-stack","docId":"data-structures/10-5-monotonic-stack","unlisted":false},{"type":"link","label":"10.6 Priority Queue","href":"/leetcode_101/en/data-structures/10-6-priority-queue","docId":"data-structures/10-6-priority-queue","unlisted":false},{"type":"link","label":"10.7 Double-Ended Queue","href":"/leetcode_101/en/data-structures/10-7-deque","docId":"data-structures/10-7-deque","unlisted":false},{"type":"link","label":"10.8 Hash Table","href":"/leetcode_101/en/data-structures/10-8-hash-table","docId":"data-structures/10-8-hash-table","unlisted":false},{"type":"link","label":"10.9 Multisets and Mappings","href":"/leetcode_101/en/data-structures/10-9-multisets-and-maps","docId":"data-structures/10-9-multisets-and-maps","unlisted":false},{"type":"link","label":"10.10 Prefix Sum and Integral Image","href":"/leetcode_101/en/data-structures/10-10-prefix-sum-integral-image","docId":"data-structures/10-10-prefix-sum-integral-image","unlisted":false},{"type":"link","label":"10.11 Exercises","href":"/leetcode_101/en/data-structures/10-11-exercises","docId":"data-structures/10-11-exercises","unlisted":false}],"href":"/leetcode_101/en/category/10-\u5999\u7528\u6570\u636e\u7ed3\u6784"},{"type":"category","label":"11. Tricky String Problems","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"11.1 Introduction","href":"/leetcode_101/en/string-manipulation/11-1-introduction","docId":"string-manipulation/11-1-introduction","unlisted":false},{"type":"link","label":"11.2 String Comparison","href":"/leetcode_101/en/string-manipulation/11-2-string-comparison","docId":"string-manipulation/11-2-string-comparison","unlisted":false},{"type":"link","label":"11.3 String Parsing","href":"/leetcode_101/en/string-manipulation/11-3-string-interpretation","docId":"string-manipulation/11-3-string-interpretation","unlisted":false},{"type":"link","label":"11.4 String Matching","href":"/leetcode_101/en/string-manipulation/11-4-string-matching","docId":"string-manipulation/11-4-string-matching","unlisted":false},{"type":"link","label":"11.5 Exercises","href":"/leetcode_101/en/string-manipulation/11-5-exercises","docId":"string-manipulation/11-5-exercises","unlisted":false}],"href":"/leetcode_101/en/category/11-\u4ee4\u4eba\u5934\u5927\u7684\u5b57\u7b26\u4e32"},{"type":"category","label":"12. The Three Musketeers of Pointers: Linked Lists","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"12.1 Data Structure Introduction","href":"/leetcode_101/en/linked-lists/12-1-data-structure-introduction","docId":"linked-lists/12-1-data-structure-introduction","unlisted":false},{"type":"link","label":"12.2 Basic Operations on Linked Lists","href":"/leetcode_101/en/linked-lists/12-2-basic-linked-list-operations","docId":"linked-lists/12-2-basic-linked-list-operations","unlisted":false},{"type":"link","label":"12.3 Other Linked List Techniques","href":"/leetcode_101/en/linked-lists/12-3-other-linked-list-techniques","docId":"linked-lists/12-3-other-linked-list-techniques","unlisted":false},{"type":"link","label":"12.4 Exercises","href":"/leetcode_101/en/linked-lists/12-4-exercises","docId":"linked-lists/12-4-exercises","unlisted":false}],"href":"/leetcode_101/en/category/12-\u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e00\u94fe\u8868"},{"type":"category","label":"13. The Three Musketeers of Pointers: Trees","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"13.1 Data Structure Introduction","href":"/leetcode_101/en/trees/13-1-data-structure-introduction","docId":"trees/13-1-data-structure-introduction","unlisted":false},{"type":"link","label":"13.2 Tree Recursion","href":"/leetcode_101/en/trees/13-2-tree-recursion","docId":"trees/13-2-tree-recursion","unlisted":false},{"type":"link","label":"13.3 Level Order Traversal","href":"/leetcode_101/en/trees/13-3-level-order-traversal","docId":"trees/13-3-level-order-traversal","unlisted":false},{"type":"link","label":"13.4  Preorder, Inorder, and Postorder Traversals","href":"/leetcode_101/en/trees/13-4-preorder-inorder-postorder-traversal","docId":"trees/13-4-preorder-inorder-postorder-traversal","unlisted":false},{"type":"link","label":"13.5 Binary Search Tree","href":"/leetcode_101/en/trees/13-5-binary-search-tree","docId":"trees/13-5-binary-search-tree","unlisted":false},{"type":"link","label":"13.6 Trie","href":"/leetcode_101/en/trees/13-6-trie","docId":"trees/13-6-trie","unlisted":false},{"type":"link","label":"13.7 Exercises","href":"/leetcode_101/en/trees/13-7-exercises","docId":"trees/13-7-exercises","unlisted":false}],"href":"/leetcode_101/en/category/13-\u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e8c\u6811"},{"type":"category","label":"14. The Three Musketeers of Pointers: Graphs","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"14.1 Data Structure Introduction","href":"/leetcode_101/en/graphs/14-1-data-structure-introduction","docId":"graphs/14-1-data-structure-introduction","unlisted":false},{"type":"link","label":"14.2 Bipartite Graph","href":"/leetcode_101/en/graphs/14-2-bipartite-graph","docId":"graphs/14-2-bipartite-graph","unlisted":false},{"type":"link","label":"14.3 Topological Sort","href":"/leetcode_101/en/graphs/14-3-topological-sorting","docId":"graphs/14-3-topological-sorting","unlisted":false},{"type":"link","label":"14.4 Exercises","href":"/leetcode_101/en/graphs/14-4-exercises","docId":"graphs/14-4-exercises","unlisted":false}],"href":"/leetcode_101/en/category/14-\u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e09\u56fe"},{"type":"category","label":"15. More Complex Data Structures","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"15.1 Introduction","href":"/leetcode_101/en/advanced-data-structures/15-1-introduction","docId":"advanced-data-structures/15-1-introduction","unlisted":false},{"type":"link","label":"15.2 Union-Find","href":"/leetcode_101/en/advanced-data-structures/15-2-union-find","docId":"advanced-data-structures/15-2-union-find","unlisted":false},{"type":"link","label":"15.3 Composite Data Structures","href":"/leetcode_101/en/advanced-data-structures/15-3-composite-data-structures","docId":"advanced-data-structures/15-3-composite-data-structures","unlisted":false},{"type":"link","label":"15.4 Exercises","href":"/leetcode_101/en/advanced-data-structures/15-4-exercises","docId":"advanced-data-structures/15-4-exercises","unlisted":false}],"href":"/leetcode_101/en/category/15-\u66f4\u52a0\u590d\u6742\u7684\u6570\u636e\u7ed3\u6784"},{"type":"link","label":"Acknowledgments","href":"/leetcode_101/en/acknowledgments","docId":"acknowledgments","unlisted":false}]},"docs":{"acknowledgments":{"id":"acknowledgments","title":"Acknowledgments","description":"Officially Recognized Supreme Supporter","sidebar":"tutorialSidebar"},"advanced-data-structures/15-1-introduction":{"id":"advanced-data-structures/15-1-introduction","title":"15.1 Introduction","description":"So far, we have explored a wide range of data structures, including the \\"pointer trio\\" (linked list, tree, and graph) and C++\'s built-in STL library. For certain problems, it is necessary not only to utilize multiple data structures but also to nest and integrate them, enabling more complex and efficient operations.","sidebar":"tutorialSidebar"},"advanced-data-structures/15-2-union-find":{"id":"advanced-data-structures/15-2-union-find","title":"15.2 Union-Find","description":"Union-Find (disjoint set) is a data structure used for dynamic connectivity problems. It efficiently connects two points and determines whether two points are connected. Given n nodes, we initialize the parent of each node to itself. To connect nodes i and j, we attach the smaller rank\'s parent to the larger rank\'s parent (union by rank). To check if two nodes are connected, we find their ancestors and determine if they are the same, applying path compression to speed up subsequent queries.","sidebar":"tutorialSidebar"},"advanced-data-structures/15-3-composite-data-structures":{"id":"advanced-data-structures/15-3-composite-data-structures","title":"15.3 Composite Data Structures","description":"This type of problem often uses a hash table or ordered map for auxiliary record-keeping to speed up lookups; paired with arrays or linked lists for continuous data storage to expedite sequential selection or value deletion.","sidebar":"tutorialSidebar"},"advanced-data-structures/15-4-exercises":{"id":"advanced-data-structures/15-4-exercises","title":"15.4 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"binary-search-techniques/3-1-algorithm-explanation":{"id":"binary-search-techniques/3-1-algorithm-explanation","title":"3.1 Algorithm Explanation","description":"Binary search, also known as bisection or halving search (binary search, bisect), reduces the complexity of a search operation by dividing the search interval into two parts at each step and only proceeding with one part. For an array of length $O(n)$, the time complexity of binary search is $O(\\\\log n)$.","sidebar":"tutorialSidebar"},"binary-search-techniques/3-2-square-root":{"id":"binary-search-techniques/3-2-square-root","title":"3.2 Calculating Square Root","description":"69. Sqrt(x)","sidebar":"tutorialSidebar"},"binary-search-techniques/3-3-interval-search":{"id":"binary-search-techniques/3-3-interval-search","title":"3.3 Find Range","description":"34. Find First and Last Position of Element in Sorted Array","sidebar":"tutorialSidebar"},"binary-search-techniques/3-4-peak-finding":{"id":"binary-search-techniques/3-4-peak-finding","title":"3.4 Find Maximum","description":"162. Find Peak Element","sidebar":"tutorialSidebar"},"binary-search-techniques/3-5-rotated-array-search":{"id":"binary-search-techniques/3-5-rotated-array-search","title":"3.5 Search in Rotated Array","description":"81. Search in Rotated Sorted Array II","sidebar":"tutorialSidebar"},"binary-search-techniques/3-6-exercises":{"id":"binary-search-techniques/3-6-exercises","title":"3.6 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"bitwise-operations/9-1-common-techniques":{"id":"bitwise-operations/9-1-common-techniques","title":"9.1 Common Techniques","description":"Bit manipulation is a unique category in algorithm problems. By leveraging the characteristics of binary bit operations, we can achieve fascinating optimizations and calculations. Here are some common bitwise operators and their functions:","sidebar":"tutorialSidebar"},"bitwise-operations/9-2-basic-bitwise-problems":{"id":"bitwise-operations/9-2-basic-bitwise-problems","title":"9.2 Basic Problems in Bit Manipulation","description":"461. Hamming Distance","sidebar":"tutorialSidebar"},"bitwise-operations/9-3-binary-properties":{"id":"bitwise-operations/9-3-binary-properties","title":"9.3 Binary Features","description":"By leveraging some binary features, we can apply bitwise operations to solve a wider range of problems.","sidebar":"tutorialSidebar"},"bitwise-operations/9-4-exercises":{"id":"bitwise-operations/9-4-exercises","title":"9.4 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"data-structures/10-1-cpp-stl":{"id":"data-structures/10-1-cpp-stl","title":"10.1 C++ STL","description":"When solving problems, we almost always rely on various data structures to assist us. Therefore, we must familiarize ourselves with the characteristics of each data structure. C++ STL provides several data structures (the actual underlying implementation may vary depending on the compiler):","sidebar":"tutorialSidebar"},"data-structures/10-10-prefix-sum-integral-image":{"id":"data-structures/10-10-prefix-sum-integral-image","title":"10.10 Prefix Sum and Integral Image","description":"A one-dimensional prefix sum (cumulative sum, cumsum) and a two-dimensional integral image (summed-area table, image integral) are techniques used to precompute the sums of one-dimensional segments or two-dimensional rectangles up to each position. This allows for faster calculations and queries. If you need to index values from the prefix sum or integral image, they can be stored in a hash table. If you need to record values for each position, they can be stored in one-dimensional or two-dimensional arrays, often in conjunction with dynamic programming.","sidebar":"tutorialSidebar"},"data-structures/10-11-exercises":{"id":"data-structures/10-11-exercises","title":"10.11 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"data-structures/10-2-python-data-structures":{"id":"data-structures/10-2-python-data-structures","title":"10.2 Python Common Data Structures","description":"Similar to C++ STL, Python also provides various data structures (the underlying details may vary depending on the implementation):","sidebar":"tutorialSidebar"},"data-structures/10-3-arrays":{"id":"data-structures/10-3-arrays","title":"10.3 Arrays","description":"448. Find All Numbers Disappeared in an Array","sidebar":"tutorialSidebar"},"data-structures/10-4-stack-and-queue":{"id":"data-structures/10-4-stack-and-queue","title":"10.4 Stacks and Queues","description":"232. Implement Queue using Stacks","sidebar":"tutorialSidebar"},"data-structures/10-5-monotonic-stack":{"id":"data-structures/10-5-monotonic-stack","title":"10.5 Monotonic Stack","description":"Monotonic Stack is a technique that maintains the monotonic increasing (or decreasing) property of a stack to solve comparison problems in $O(n)$ time complexity.","sidebar":"tutorialSidebar"},"data-structures/10-6-priority-queue":{"id":"data-structures/10-6-priority-queue","title":"10.6 Priority Queue","description":"Priority queue allows retrieving the maximum value in $O(1)$ time and inserting or removing the maximum value in $O(\\\\log n)$ time.","sidebar":"tutorialSidebar"},"data-structures/10-7-deque":{"id":"data-structures/10-7-deque","title":"10.7 Double-Ended Queue","description":"239. Sliding Window Maximum","sidebar":"tutorialSidebar"},"data-structures/10-8-hash-table":{"id":"data-structures/10-8-hash-table","title":"10.8 Hash Table","description":"A hash table (also known as a hash map) uses $O(n)$ space complexity to store data. By leveraging a hash function, it maps positions to achieve approximate $O(1)$ time complexity for insertion, lookup, and deletion operations. Hash tables can be utilized for tasks such as frequency counting and content recording.","sidebar":"tutorialSidebar"},"data-structures/10-9-multisets-and-maps":{"id":"data-structures/10-9-multisets-and-maps","title":"10.9 Multisets and Mappings","description":"332. Reconstruct Itinerary","sidebar":"tutorialSidebar"},"divide-and-conquer/7-1-algorithm-explanation":{"id":"divide-and-conquer/7-1-algorithm-explanation","title":"7.1 Algorithm Explanation","description":"As the name suggests, divide and conquer problems consist of two parts: \\"divide\\" and \\"conquer.\\" By breaking the original problem into subproblems and then solving and merging these subproblems, we can solve the original problem. Merge sort, introduced in the sorting chapter, is a classic example of divide and conquer. In merge sort, the \\"divide\\" step splits the array into two smaller arrays using recursion until we get multiple arrays of length 1. The \\"conquer\\" step merges two sorted arrays into a single sorted array, starting from arrays of length 1 and eventually forming the final array.","sidebar":"tutorialSidebar"},"divide-and-conquer/7-2-expression-problems":{"id":"divide-and-conquer/7-2-expression-problems","title":"7.2 Expression Problems","description":"241. Di\ufb00erent Ways to Add Parentheses","sidebar":"tutorialSidebar"},"divide-and-conquer/7-3-exercises":{"id":"divide-and-conquer/7-3-exercises","title":"7.3 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"dynamic-programming/6-1-algorithm-explanation":{"id":"dynamic-programming/6-1-algorithm-explanation","title":"6.1 Algorithm Explanation","description":"Here, we quote Wikipedia\u2019s description: \\"Dynamic Programming (DP) is effective in finding the optimal solution for problems with many overlapping subproblems. It redefines the problem into subproblems. To avoid repeatedly solving these subproblems, their results are progressively computed and stored, starting from simpler problems until the entire problem is resolved. Therefore, dynamic programming saves the results of recursion and avoids spending time solving the same problems repeatedly. Dynamic programming can only be applied to problems with an optimal substructure. The optimal substructure means that the local optimal solution can determine the global optimal solution (this requirement is not always completely met for some problems, so certain approximations may be introduced). Simply put, the problem can be broken down into subproblems to solve.\\"","sidebar":"tutorialSidebar"},"dynamic-programming/6-2-basic-dp-1d":{"id":"dynamic-programming/6-2-basic-dp-1d","title":"6.2 Basic Dynamic Programming: One-Dimensional","description":"70. Climbing Stairs","sidebar":"tutorialSidebar"},"dynamic-programming/6-3-basic-dp-2d":{"id":"dynamic-programming/6-3-basic-dp-2d","title":"6.3 Basic Dynamic Programming: Two-Dimensional","description":"64. Minimum Path Sum","sidebar":"tutorialSidebar"},"dynamic-programming/6-4-partition-problems":{"id":"dynamic-programming/6-4-partition-problems","title":"6.4 Partition Type Problems","description":"279. Perfect Squares","sidebar":"tutorialSidebar"},"dynamic-programming/6-5-subsequence-problems":{"id":"dynamic-programming/6-5-subsequence-problems","title":"6.5 Subsequence Problem","description":"300. Longest Increasing Subsequence","sidebar":"tutorialSidebar"},"dynamic-programming/6-6-knapsack-problem":{"id":"dynamic-programming/6-6-knapsack-problem","title":"6.6 Knapsack Problem","description":"The knapsack problem is a combinatorial optimization NP-complete problem: given n items and a knapsack with weight capacity w, where each item has a weight and a value, determine which items to include in the knapsack to maximize the total value. If each item can only be chosen 0 or 1 time, the problem is called the 0-1 knapsack problem; if there is no limit to the number of items chosen, it is called the unbounded knapsack problem.","sidebar":"tutorialSidebar"},"dynamic-programming/6-7-string-editing":{"id":"dynamic-programming/6-7-string-editing","title":"6.7 String Editing","description":"72. Edit Distance","sidebar":"tutorialSidebar"},"dynamic-programming/6-8-stock-trading":{"id":"dynamic-programming/6-8-stock-trading","title":"6.8 Stock Trading","description":"Stock trading problems can often be solved using dynamic programming. For more complex stock trading scenarios, such as requiring cooldown periods or transaction fees, a state machine implemented with dynamic programming is a common approach.","sidebar":"tutorialSidebar"},"dynamic-programming/6-9-exercises":{"id":"dynamic-programming/6-9-exercises","title":"6.9 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"graphs/14-1-data-structure-introduction":{"id":"graphs/14-1-data-structure-introduction","title":"14.1 Data Structure Introduction","description":"As the third member of the pointer triumvirate, graphs are an advanced version of trees. A graph can be classified as directed or undirected, cyclic or acyclic, and connected or disconnected. A tree is essentially a connected, undirected, acyclic graph. Another common type of graph is the Directed Acyclic Graph (DAG).","sidebar":"tutorialSidebar"},"graphs/14-2-bipartite-graph":{"id":"graphs/14-2-bipartite-graph","title":"14.2 Bipartite Graph","description":"The bipartite graph algorithm, also known as the coloring method, uses a breadth-first search (BFS). A graph is bipartite if its nodes can be colored using two colors such that no two adjacent nodes have the same color.","sidebar":"tutorialSidebar"},"graphs/14-3-topological-sorting":{"id":"graphs/14-3-topological-sorting","title":"14.3 Topological Sort","description":"Topological Sort is a common algorithm used to order nodes in a directed acyclic graph (DAG). Given $N$ nodes in a DAG, the goal is to arrange them in a linear sequence such that if node $i$ points to node $j$, then $i$ appears before $j$ in the sequence. The result of a topological sort is not unique as long as the above condition is satisfied.","sidebar":"tutorialSidebar"},"graphs/14-4-exercises":{"id":"graphs/14-4-exercises","title":"14.4 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"greedy-algorithms/1-1-algorithm-explanation":{"id":"greedy-algorithms/1-1-algorithm-explanation","title":"1.1 Algorithm Explanation","description":"As the name implies, a greedy algorithm or greedy strategy adopts a greedy approach, ensuring that each step is locally optimal, thereby resulting in a globally optimal solution.","sidebar":"tutorialSidebar"},"greedy-algorithms/1-2-assignment-problems":{"id":"greedy-algorithms/1-2-assignment-problems","title":"1.2 Distribution Problem","description":"455. Assign Cookies","sidebar":"tutorialSidebar"},"greedy-algorithms/1-3-interval-problems":{"id":"greedy-algorithms/1-3-interval-problems","title":"1.3 Interval Problem","description":"435. Non-overlapping Intervals","sidebar":"tutorialSidebar"},"greedy-algorithms/1-4-exercises":{"id":"greedy-algorithms/1-4-exercises","title":"1.4 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"index":{"id":"index","title":"LeetCode 101: A Grinding Guide (2nd Edition)","description":"Author: Chang Gao","sidebar":"tutorialSidebar"},"linked-lists/12-1-data-structure-introduction":{"id":"linked-lists/12-1-data-structure-introduction","title":"12.1 Data Structure Introduction","description":"A (singly) linked list is a data structure composed of nodes and pointers. Each node contains a value and a pointer to the next node. As a result, many linked list problems can be solved using recursion. Unlike arrays, a linked list cannot directly access the value of any node; it must traverse through pointers to reach the desired node. Similarly, the length of a linked list cannot be determined unless it is fully traversed or tracked using another data structure. LeetCode\u2019s default representation of a linked list is as follows.","sidebar":"tutorialSidebar"},"linked-lists/12-2-basic-linked-list-operations":{"id":"linked-lists/12-2-basic-linked-list-operations","title":"12.2 Basic Operations on Linked Lists","description":"206. Reverse Linked List","sidebar":"tutorialSidebar"},"linked-lists/12-3-other-linked-list-techniques":{"id":"linked-lists/12-3-other-linked-list-techniques","title":"12.3 Other Linked List Techniques","description":"160. Intersection of Two Linked Lists","sidebar":"tutorialSidebar"},"linked-lists/12-4-exercises":{"id":"linked-lists/12-4-exercises","title":"12.4 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"mathematical-solutions/8-1-introduction":{"id":"mathematical-solutions/8-1-introduction","title":"8.1 Introduction","description":"For the numerous math problems on LeetCode, we strive to categorize and explain them by type. However, many math problems have solutions that are not universally applicable, making it challenging to summarize all problem-solving techniques in one go. Therefore, we have selected a few classic or representative problems for your reference.","sidebar":"tutorialSidebar"},"mathematical-solutions/8-2-lcm-gcd":{"id":"mathematical-solutions/8-2-lcm-gcd","title":"8.2 Least Common Multiple and Greatest Common Divisor","description":"Using the Euclidean algorithm, we can efficiently calculate the greatest common divisor (GCD) of two numbers. Multiplying the two numbers and dividing the product by their GCD gives the least common multiple (LCM).","sidebar":"tutorialSidebar"},"mathematical-solutions/8-3-prime-numbers":{"id":"mathematical-solutions/8-3-prime-numbers","title":"8.3 Prime Numbers","description":"Prime numbers are integers greater than 1 that have no divisors other than 1 and themselves. It is important to note that every number can be expressed as a product of prime numbers.","sidebar":"tutorialSidebar"},"mathematical-solutions/8-4-number-processing":{"id":"mathematical-solutions/8-4-number-processing","title":"8.4 Numerical Processing","description":"504. Base 7","sidebar":"tutorialSidebar"},"mathematical-solutions/8-5-random-sampling":{"id":"mathematical-solutions/8-5-random-sampling","title":"8.5 Random and Sampling","description":"384. Shuffle an Array","sidebar":"tutorialSidebar"},"mathematical-solutions/8-6-exercises":{"id":"mathematical-solutions/8-6-exercises","title":"8.6 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"searching-algorithms/5-1-algorithm-explanation":{"id":"searching-algorithms/5-1-algorithm-explanation","title":"5.1 Algorithm Explanation","description":"Depth First Search (DFS) and Breadth First Search (BFS) are two of the most common priority search methods. They are widely used for searching in structures such as graphs and trees.","sidebar":"tutorialSidebar"},"searching-algorithms/5-2-depth-first-search":{"id":"searching-algorithms/5-2-depth-first-search","title":"5.2 Depth First Search","description":"Depth First Search (DFS) is a search method where, upon encountering a new node, you immediately traverse that new node. Therefore, traversal requires a Last In, First Out (LIFO) stack, which can also be implemented using recursion, equivalent to using a stack. In a tree structure, since traversal always invokes the new node, it appears as if progressing in the \\"depth\\" direction. In Python, collections.deque can be used to implement the stack in C++. However, in most cases, using vector in C++ or list in Python is preferred as these structures not only support LIFO but also allow random access.","sidebar":"tutorialSidebar"},"searching-algorithms/5-3-backtracking":{"id":"searching-algorithms/5-3-backtracking","title":"5.3 Backtracking","description":"Backtracking is a special case of priority search, also known as the trial-and-error method. It is commonly used in depth-first search when the state of nodes needs to be recorded. Typically, problems involving permutations, combinations, or selections are more conveniently solved using backtracking.","sidebar":"tutorialSidebar"},"searching-algorithms/5-4-breadth-first-search":{"id":"searching-algorithms/5-4-breadth-first-search","title":"5.4 Breadth-First Search","description":"Breadth-First Search (BFS) differs from Depth-First Search in that it traverses level by level, so it requires a first-in, first-out queue instead of the last-in, first-out stack used in DFS. Since BFS processes nodes by levels, it explores nodes in a \\"broad\\" manner and is often used for solving shortest path problems. In Python, we can use collections.deque to implement the queue used in C++.","sidebar":"tutorialSidebar"},"searching-algorithms/5-5-exercises":{"id":"searching-algorithms/5-5-exercises","title":"5.5 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"sorting-algorithms/4-1-common-sorting-algorithms":{"id":"sorting-algorithms/4-1-common-sorting-algorithms","title":"4.1 Common Sorting Algorithms","description":"Although sorting can be achieved in C++ and Python using the sort function and it is rare to write sorting algorithms manually during coding challenges, understanding various sorting algorithms helps deepen your knowledge of basic algorithms and solve problems derived from these algorithms. Here, we introduce two sorting algorithms with a time complexity of $O(n \\\\log n)$: Quick Sort and Merge Sort. The former is generally faster, while the latter ensures that elements with the same value maintain their relative order in the array (i.e., it is a \\"stable sort\\").","sidebar":"tutorialSidebar"},"sorting-algorithms/4-2-quick-select":{"id":"sorting-algorithms/4-2-quick-select","title":"4.2 Quick Select","description":"215. Kth Largest Element in an Array","sidebar":"tutorialSidebar"},"sorting-algorithms/4-3-bucket-sort":{"id":"sorting-algorithms/4-3-bucket-sort","title":"4.3 Bucket Sort","description":"347. Top K Frequent Elements","sidebar":"tutorialSidebar"},"sorting-algorithms/4-4-exercises":{"id":"sorting-algorithms/4-4-exercises","title":"4.4 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"string-manipulation/11-1-introduction":{"id":"string-manipulation/11-1-introduction","title":"11.1 Introduction","description":"Strings can be considered as arrays of characters. Since strings are a frequently used data type in programming, there are many problems related to string manipulation. Below are some common types of such problems.","sidebar":"tutorialSidebar"},"string-manipulation/11-2-string-comparison":{"id":"string-manipulation/11-2-string-comparison","title":"11.2 String Comparison","description":"242. Valid Anagram","sidebar":"tutorialSidebar"},"string-manipulation/11-3-string-interpretation":{"id":"string-manipulation/11-3-string-interpretation","title":"11.3 String Parsing","description":"227. Basic Calculator II","sidebar":"tutorialSidebar"},"string-manipulation/11-4-string-matching":{"id":"string-manipulation/11-4-string-matching","title":"11.4 String Matching","description":"28. Implement strStr()","sidebar":"tutorialSidebar"},"string-manipulation/11-5-exercises":{"id":"string-manipulation/11-5-exercises","title":"11.5 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"trees/13-1-data-structure-introduction":{"id":"trees/13-1-data-structure-introduction","title":"13.1 Data Structure Introduction","description":"As an upgraded version of the (single) linked list, the trees we commonly encounter are typically binary trees, where each node has at most two child nodes. Unless otherwise specified, trees are assumed to have no circular structures. LeetCode\'s default representation of trees is as follows:","sidebar":"tutorialSidebar"},"trees/13-2-tree-recursion":{"id":"trees/13-2-tree-recursion","title":"13.2 Tree Recursion","description":"For simple recursion problems, some LeetCode experts prefer to write one-line code, solving problems with a single line. While we will showcase such solutions, beginners are still advised to use multi-line if-else statements.","sidebar":"tutorialSidebar"},"trees/13-3-level-order-traversal":{"id":"trees/13-3-level-order-traversal","title":"13.3 Level Order Traversal","description":"We can use Breadth-First Search (BFS) for level order traversal. Note that it is unnecessary to use two queues to separately store the current layer\'s nodes and the next layer\'s nodes. At the beginning of each layer\'s traversal, the number of nodes in the current queue equals the number of nodes in the current layer. By controlling the traversal to only process that many nodes, we ensure that the traversal covers only the current layer.","sidebar":"tutorialSidebar"},"trees/13-4-preorder-inorder-postorder-traversal":{"id":"trees/13-4-preorder-inorder-postorder-traversal","title":"13.4  Preorder, Inorder, and Postorder Traversals","description":"Preorder traversal, inorder traversal, and postorder traversal are three ways to traverse a binary tree using Depth-First Search (DFS). They differ only in the order of node visits, while the rest remains the same. Consider the following binary tree:","sidebar":"tutorialSidebar"},"trees/13-5-binary-search-tree":{"id":"trees/13-5-binary-search-tree","title":"13.5 Binary Search Tree","description":"A Binary Search Tree (BST) is a special type of binary tree starting from the root, move to the left if the current node\'s value is greater than the target value, or move to the right if it\'s smaller. Additionally, since a BST is ordered, an in-order traversal of the tree results in a sorted array.","sidebar":"tutorialSidebar"},"trees/13-6-trie":{"id":"trees/13-6-trie","title":"13.6 Trie","description":"A Trie is a tree-like data structure used to determine whether a string exists or whether it has a specific prefix.","sidebar":"tutorialSidebar"},"trees/13-7-exercises":{"id":"trees/13-7-exercises","title":"13.7 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"},"two-pointer-techniques/2-1-algorithm-explanation":{"id":"two-pointer-techniques/2-1-algorithm-explanation","title":"2.1 Algorithm Explanation","description":"The two-pointer technique is primarily used for traversing arrays, where two pointers point to different elements to collaborate on a task. It can also be extended to multiple pointers across multiple arrays.","sidebar":"tutorialSidebar"},"two-pointer-techniques/2-2-two-sum":{"id":"two-pointer-techniques/2-2-two-sum","title":"2.2 Two Sum","description":"167. Two Sum II - Input array is sorted","sidebar":"tutorialSidebar"},"two-pointer-techniques/2-3-merge-sorted-arrays":{"id":"two-pointer-techniques/2-3-merge-sorted-arrays","title":"2.3 Merging Two Sorted Arrays","description":"88. Merge Sorted Array","sidebar":"tutorialSidebar"},"two-pointer-techniques/2-4-sliding-window":{"id":"two-pointer-techniques/2-4-sliding-window","title":"2.4 Sliding Window","description":"76. Minimum Window Substring","sidebar":"tutorialSidebar"},"two-pointer-techniques/2-5-fast-slow-pointers":{"id":"two-pointer-techniques/2-5-fast-slow-pointers","title":"2.5 Fast and Slow Pointers","description":"142. Linked List Cycle II","sidebar":"tutorialSidebar"},"two-pointer-techniques/2-6-exercises":{"id":"two-pointer-techniques/2-6-exercises","title":"2.6 Exercises","description":"Basic Difficulty","sidebar":"tutorialSidebar"}}}}')}}]);