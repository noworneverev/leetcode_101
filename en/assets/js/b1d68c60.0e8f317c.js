"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[4963],{3839:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"string-manipulation/11-2-string-comparison","title":"11.2 String Comparison","description":"242. Valid Anagram","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/11-string-manipulation/11-2-string-comparison.mdx","sourceDirName":"11-string-manipulation","slug":"/string-manipulation/11-2-string-comparison","permalink":"/leetcode_101/en/string-manipulation/11-2-string-comparison","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/11-string-manipulation/11-2-string-comparison.mdx","tags":[],"version":"current","sidebarPosition":60,"frontMatter":{"sidebar_position":60},"sidebar":"tutorialSidebar","previous":{"title":"11.1 Introduction","permalink":"/leetcode_101/en/string-manipulation/11-1-introduction"},"next":{"title":"11.3 String Parsing","permalink":"/leetcode_101/en/string-manipulation/11-3-string-interpretation"}}');var r=t(4848),s=t(8453);const a={sidebar_position:60},o="11.2 String Comparison",l={},c=[{value:"242. Valid Anagram",id:"242-valid-anagram",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"205. Isomorphic Strings",id:"205-isomorphic-strings",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"647. Palindromic Substrings",id:"647-palindromic-substrings",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3},{value:"696. Count Binary Substrings",id:"696-count-binary-substrings",level:2},{value:"Problem Description",id:"problem-description-3",level:3},{value:"Input and Output Example",id:"input-and-output-example-3",level:3},{value:"Solution Explanation",id:"solution-explanation-3",level:3},{value:"1249. Minimum Remove to Make Valid Parentheses",id:"1249-minimum-remove-to-make-valid-parentheses",level:2},{value:"Problem Description",id:"problem-description-4",level:3},{value:"Input and Output Example",id:"input-and-output-example-4",level:3},{value:"Solution Explanation",id:"solution-explanation-4",level:3}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components},{TabItem:t,Tabs:i}=e;return t||h("TabItem",!0),i||h("Tabs",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"112-string-comparison",children:"11.2 String Comparison"})}),"\n",(0,r.jsx)(e.h2,{id:"242-valid-anagram",children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/valid-anagram/",children:"242. Valid Anagram"})}),"\n",(0,r.jsx)(e.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,r.jsx)(e.p,{children:"Determine if two strings contain exactly the same characters."}),"\n",(0,r.jsx)(e.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,r.jsx)(e.p,{children:"Input two strings and output a boolean indicating whether the two strings meet the condition."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'Input: s = "anagram", t = "nagaram"\nOutput: true\n'})}),"\n",(0,r.jsx)(e.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,r.jsx)(e.p,{children:"We can use a hash table or an array to count the frequency of each character in both strings. If the frequencies match, it means the strings contain the exact same characters."}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)(t,{value:"cpp",label:"C++",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"bool isAnagram(string s, string t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    vector<int> counts(26, 0);\n    for (int i = 0; i < s.length(); ++i) {\n        ++counts[s[i] - \u2019a\u2019];\n        --counts[t[i] - \u2019a\u2019];\n    }\n    return all_of(counts.begin(), counts.end(), [](int c) { return c == 0; });\n}\n"})})}),(0,r.jsx)(t,{value:"py",label:"Python",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-py",children:"def isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    counter = Counter(s)\n    counter.subtract(t)\n    return all(v == 0 for v in counter.values())\n"})})})]}),"\n",(0,r.jsx)(e.h2,{id:"205-isomorphic-strings",children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/isomorphic-strings/",children:"205. Isomorphic Strings"})}),"\n",(0,r.jsx)(e.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,r.jsx)(e.p,{children:"Determine if two strings are isomorphic. Two strings are isomorphic if characters in one string can be replaced to get the other string, while ensuring that no two different characters map to the same character."}),"\n",(0,r.jsx)(e.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,r.jsx)(e.p,{children:"Input two strings and output a boolean indicating whether they meet the condition."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'Input: s = "paper", t = "title"\nOutput: true\n'})}),"\n",(0,r.jsxs)(e.p,{children:["In this example, by replacing ",(0,r.jsx)(e.code,{children:"p"}),", ",(0,r.jsx)(e.code,{children:"a"}),", ",(0,r.jsx)(e.code,{children:"e"}),", ",(0,r.jsx)(e.code,{children:"r"})," in ",(0,r.jsx)(e.code,{children:"s"})," with ",(0,r.jsx)(e.code,{children:"t"}),", ",(0,r.jsx)(e.code,{children:"i"}),", ",(0,r.jsx)(e.code,{children:"l"}),", ",(0,r.jsx)(e.code,{children:"e"})," respectively, the two strings can become identical."]}),"\n",(0,r.jsx)(e.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,r.jsx)(e.p,{children:"We can reformulate the problem: track the first appearance position of each character in both strings. If the characters at the same position in both strings have the same first appearance position, the strings are isomorphic."}),"\n",(0,r.jsxs)(e.p,{children:['For example, for "paper" and "title," if we reach the third characters ',(0,r.jsx)(e.code,{children:"p"})," and ",(0,r.jsx)(e.code,{children:"t"}),", we find their first appearances are at the first character, which satisfies the isomorphic condition. We can use a hash table for storage or a fixed-length array of size 128 (for the total number of ASCII characters)."]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)(t,{value:"cpp",label:"C++",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"bool isIsomorphic(string s, string t) {\n    vector<int> s_init(128, 0), t_init(128, 0);\n    for (int i = 0; i < s.length(); ++i) {\n        if (s_init[s[i]] != t_init[t[i]]) {\n            return false;\n        }\n        s_init[s[i]] = t_init[t[i]] = i + 1;\n    }\n    return true;\n}\n"})})}),(0,r.jsx)(t,{value:"py",label:"Python",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-py",children:"def isIsomorphic(s: str, t: str) -> bool:\n    s_init, t_init = [0] * 128, [0] * 128\n    \n    for i in range(len(s)):\n        if s_init[ord(s[i])] != t_init[ord(t[i])]:\n            return False\n        s_init[ord(s[i])] = t_init[ord(t[i])] = i + 1\n    \n    return True\n\n"})})})]}),"\n",(0,r.jsx)(e.h2,{id:"647-palindromic-substrings",children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/palindromic-substrings/",children:"647. Palindromic Substrings"})}),"\n",(0,r.jsx)(e.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,r.jsx)(e.p,{children:"Given a string, find how many of its substrings are palindromic. A palindrome is defined as being symmetric from left to right."}),"\n",(0,r.jsx)(e.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,r.jsx)(e.p,{children:"Input is a string, and output is an integer representing the count of palindromic substrings."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'Input: "aaa"\nOutput: 6\n'})}),"\n",(0,r.jsx)(e.p,{children:'The six palindromic substrings are ["a", "a", "a", "aa", "aa", "aaa"].'}),"\n",(0,r.jsx)(e.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,r.jsx)(e.p,{children:"We can start from every position in the string and extend to the left and right, counting how many palindromic substrings have the current position as their center."}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)(t,{value:"cpp",label:"C++",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"// Auxiliary function\nint extendSubstrings(string s, int l, int r) {\n    int count = 0, n = s.length();\n    while (l >= 0 && r < n && s[l] == s[r]) {\n        --l;\n        ++r;\n        ++count;\n    }\n    return count;\n}\n// Main function\nint countSubstrings(string s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        count += extendSubstrings(s, i, i);      // Odd length\n        count += extendSubstrings(s, i, i + 1);  // Even length\n    }\n    return count;\n}\n"})})}),(0,r.jsx)(t,{value:"py",label:"Python",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-py",children:"# Auxiliary function\ndef extendSubstrings(s: str, l: int, r: int) -> int:\n    count, n = 0, len(s)\n    while l >= 0 and r < n and s[l] == s[r]:\n        count += 1\n        l -= 1\n        r += 1\n    return count\n\n# Main function\ndef countSubstrings(s: str) -> int:\n    return sum(\n        # Odd length + Even length\n        extendSubstrings(s, i, i) + extendSubstrings(s, i, i + 1)\n        for i in range(len(s))\n    )\n\n"})})})]}),"\n",(0,r.jsx)(e.h2,{id:"696-count-binary-substrings",children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/count-binary-substrings/",children:"696. Count Binary Substrings"})}),"\n",(0,r.jsx)(e.h3,{id:"problem-description-3",children:"Problem Description"}),"\n",(0,r.jsx)(e.p,{children:"Given a binary string (composed of '0's and '1's), count the number of non-empty substrings where the number of '0's and '1's are equal, and all '0's and '1's must appear consecutively (e.g., \"0011\", \"1100\"; but \"0101\" is not valid)."}),"\n",(0,r.jsx)(e.h3,{id:"input-and-output-example-3",children:"Input and Output Example"}),"\n",(0,r.jsx)(e.p,{children:"Input is a string, and output is an integer representing the count of valid substrings."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'Input: "00110011"\nOutput: 6\n'})}),"\n",(0,r.jsx)(e.p,{children:'In this example, the six substrings where \'0\'s and \'1\'s are equal are ["0011", "01", "1100", "10", "0011", "01"].'}),"\n",(0,r.jsx)(e.h3,{id:"solution-explanation-3",children:"Solution Explanation"}),"\n",(0,r.jsx)(e.p,{children:"Traverse the string from left to right, keeping track of the length of consecutive characters that are the same as the current character, as well as the length of the consecutive different characters before it. For example, in \"00110\", the last '0' has:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"A consecutive length of 1 for '0', because there's only one '0' at the end."}),"\n",(0,r.jsx)(e.li,{children:"A consecutive length of 2 for '1', because there are two '1's right before it."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"If the length of the consecutive different characters is greater than or equal to the current consecutive length, then there exists exactly one valid substring ending at the current character."}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)(t,{value:"cpp",label:"C++",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"int countBinarySubstrings(string s) {\n    int prev = 0, cur = 1, count = 0;\n    for (int i = 1; i < s.length(); ++i) {\n        if (s[i] == s[i - 1]) {\n            ++cur;\n        } else {\n            prev = cur;\n            cur = 1;\n        }\n        if (prev >= cur) {\n            ++count;\n        }\n    }\n    return count;\n}\n"})})}),(0,r.jsx)(t,{value:"py",label:"Python",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-py",children:"def countBinarySubstrings(s: str) -> int:\n    prev, cur, count = 0, 1, 0\n    \n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            cur += 1\n        else:\n            prev = cur\n            cur = 1\n        if prev >= cur:\n            count += 1\n    \n    return count\n\n"})})})]}),"\n",(0,r.jsx)(e.h2,{id:"1249-minimum-remove-to-make-valid-parentheses",children:(0,r.jsx)(e.a,{href:"https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/",children:"1249. Minimum Remove to Make Valid Parentheses"})}),"\n",(0,r.jsx)(e.h3,{id:"problem-description-4",children:"Problem Description"}),"\n",(0,r.jsx)(e.p,{children:"Given a string containing letters and parentheses, determine the minimum number of parentheses to remove to make the string valid."}),"\n",(0,r.jsx)(e.h3,{id:"input-and-output-example-4",children:"Input and Output Example"}),"\n",(0,r.jsx)(e.p,{children:"Input is a string, and output is a valid string with the longest possible length after removal."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'Input: s = "lee(t(c)o)de)"\nOutput: "lee(t(c)o)de"\n'})}),"\n",(0,r.jsx)(e.p,{children:'Returning "lee(t(co)de)" or "lee(t(c)ode)" is also considered correct.'}),"\n",(0,r.jsx)(e.h3,{id:"solution-explanation-4",children:"Solution Explanation"}),"\n",(0,r.jsx)(e.p,{children:"Since only one type of parenthesis is involved, we don't necessarily need a stack to track them. Instead, we can use a temporary variable to count how many more left parentheses are present than right parentheses at any position."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"If this count becomes negative during traversal, it means there are extra right parentheses that need to be removed."}),"\n",(0,r.jsx)(e.li,{children:"At the end of the traversal, if the count is positive, it means there are extra left parentheses that need to be removed by traversing from right to left."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"A small optimization here is to first mark all positions that need to be removed and then remove them in one go."}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)(t,{value:"cpp",label:"C++",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"string minRemoveToMakeValid(string s) {\n    int count = 0, n = s.length();\n    char to_delete = '#';\n    for (char& c : s) {\n        if (c == '(') { \n            ++count; \n        } else if (c == ')') {\n            if (count > 0) {\n                --count;\n            } else {\n                c = to_delete;\n            }\n        }\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        if (count == 0) break;\n        if (s[i] == '(') {\n            s[i] = to_delete;\n            --count;\n        }\n    }\n    s.erase(remove_if(s.begin(), s.end(),\n                      [to_delete](char c) { return c == to_delete; }),\n            s.end());\n    return s;\n}\n\n"})})}),(0,r.jsx)(t,{value:"py",label:"Python",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-py",children:'def minRemoveToMakeValid(s: str) -> str:\n    count, n = 0, len(s)\n    to_delete = set()\n    \n    for i in range(n):\n        if s[i] == "(":\n            count += 1\n        elif s[i] == ")":\n            if count > 0:\n                count -= 1\n            else:\n                to_delete.add(i)\n    \n    for i in range(n - 1, -1, -1):\n        if count == 0:\n            break\n        if s[i] == "(":\n            to_delete.add(i)\n            count -= 1\n    \n    return "".join(s[i] for i in range(n) if i not in to_delete)\n\n'})})})]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}function h(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);