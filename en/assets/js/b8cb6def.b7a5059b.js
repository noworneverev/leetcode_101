"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[6737],{4032:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"two-pointer-techniques/2-5-fast-slow-pointers","title":"2.5 Fast and Slow Pointers","description":"142. Linked List Cycle II","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/2-two-pointer-techniques/2-5-fast-slow-pointers.mdx","sourceDirName":"2-two-pointer-techniques","slug":"/two-pointer-techniques/2-5-fast-slow-pointers","permalink":"/leetcode_101/en/two-pointer-techniques/2-5-fast-slow-pointers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"2.4 Sliding Window","permalink":"/leetcode_101/en/two-pointer-techniques/2-4-sliding-window"},"next":{"title":"2.6 Exercises","permalink":"/leetcode_101/en/two-pointer-techniques/2-6-exercises"}}');var i=n(4848),o=n(8453);const l={sidebar_position:9},a="2.5 Fast and Slow Pointers",r={},c=[{value:"142. Linked List Cycle II",id:"142-linked-list-cycle-ii",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3}];function d(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",...(0,o.R)(),...e.components},{TabItem:n,Tabs:s}=t;return n||p("TabItem",!0),s||p("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"25-fast-and-slow-pointers",children:"2.5 Fast and Slow Pointers"})}),"\n",(0,i.jsx)(t.h2,{id:"142-linked-list-cycle-ii",children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/linked-list-cycle-ii/",children:"142. Linked List Cycle II"})}),"\n",(0,i.jsx)(t.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,i.jsx)(t.p,{children:"Given a linked list, if there is a cycle, find the starting point of the cycle."}),"\n",(0,i.jsx)(t.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,i.jsxs)(t.p,{children:["The input is a linked list, and the output is a node in the linked list. If there is no cycle, return a null pointer.",(0,i.jsx)(t.br,{}),"\n","In this example, the node with the value 2 is the starting point of the cycle.",(0,i.jsx)(t.br,{}),"\n","If not otherwise specified, LeetCode uses the following data structure to represent a linked list."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png",alt:"alt"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None # or a ListNode\n"})}),"\n",(0,i.jsx)(t.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,i.jsx)(t.p,{children:"For the problem of detecting cycles in a linked list, there is a universal solution\u2014the fast and slow pointer method (Floyd\u2019s Cycle Detection Algorithm). Given two pointers, named slow and fast, both start at the head of the list. Each time, fast moves two steps, and slow moves one step. If fast reaches the end, it means there is no cycle. If fast can move indefinitely, it means there is a cycle, and slow and fast will eventually meet. When slow and fast meet for the first time, move fast back to the head of the list, and let both slow and fast move one step at a time. When slow and fast meet for the second time, the meeting node is the starting point of the cycle."}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsx)(t.p,{children:"For problems where you only need to determine the presence of a cycle, you can also use a hash table to check for duplicates."})}),"\n",(0,i.jsxs)(s,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"ListNode *detectCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    bool is_first_cycle = true;\n    // Detect the cycle.\n    while (fast != slow || is_first_cycle) {\n        if (fast == nullptr || fast->next == nullptr) {\n            return nullptr;\n        }\n        fast = fast->next->next;\n        slow = slow->next;\n        is_first_cycle = false;\n    }\n    // Find the node.\n    fast = head;\n    while (fast != slow) {\n        slow = slow->next;\n        fast = fast->next;\n    }\n    return fast;\n}\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"def detectCycle(head: Optional[ListNode]) -> Optional[ListNode]:\n    slow = head\n    fast = head\n    is_first_cycle = True\n    # Detect the cycle.\n    while fast != slow or is_first_cycle:\n        if fast is None or fast.next is None:\n            return None\n        fast = fast.next.next\n        slow = slow.next\n        is_first_cycle = False\n    # Find the node.\n    fast = head\n    while fast != slow:\n        fast = fast.next\n        slow = slow.next\n    return fast\n"})})})]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function p(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);