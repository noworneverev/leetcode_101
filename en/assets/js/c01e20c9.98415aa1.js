"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[5114],{3725:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"searching-algorithms/5-4-breadth-first-search","title":"5.4 Breadth-First Search","description":"Breadth-First Search (BFS) differs from Depth-First Search in that it traverses level by level, so it requires a first-in, first-out queue instead of the last-in, first-out stack used in DFS. Since BFS processes nodes by levels, it explores nodes in a \\"broad\\" manner and is often used for solving shortest path problems. In Python, we can use collections.deque to implement the queue used in C++.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/5-searching-algorithms/5-4-breadth-first-search.mdx","sourceDirName":"5-searching-algorithms","slug":"/searching-algorithms/5-4-breadth-first-search","permalink":"/leetcode_101/en/searching-algorithms/5-4-breadth-first-search","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/5-searching-algorithms/5-4-breadth-first-search.mdx","tags":[],"version":"current","sidebarPosition":24,"frontMatter":{"sidebar_position":24},"sidebar":"tutorialSidebar","previous":{"title":"5.3 Backtracking","permalink":"/leetcode_101/en/searching-algorithms/5-3-backtracking"},"next":{"title":"5.5 Exercises","permalink":"/leetcode_101/en/searching-algorithms/5-5-exercises"}}');var i=s(4848),r=s(8453);const a={sidebar_position:24},o="5.4 Breadth-First Search",d={},l=[{value:"1091. Shortest Path in Binary Matrix",id:"1091-shortest-path-in-binary-matrix",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"934. Shortest Bridge",id:"934-shortest-bridge",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"126. Word Ladder II",id:"126-word-ladder-ii",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3}];function c(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,r.R)(),...e.components},{TabItem:s,Tabs:t}=n;return s||p("TabItem",!0),t||p("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"54-breadth-first-search",children:"5.4 Breadth-First Search"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Breadth-First Search"})," (BFS) differs from Depth-First Search in that it traverses level by level, so it ",(0,i.jsx)(n.code,{children:"requires a first-in, first-out queue"}),' instead of the last-in, first-out stack used in DFS. Since BFS processes nodes by levels, it explores nodes in a "broad" manner and is often used for solving shortest path problems. In Python, we can use ',(0,i.jsx)(n.code,{children:"collections.deque"})," to implement the ",(0,i.jsx)(n.code,{children:"queue"})," used in C++."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"   1\n  / \\\n  2 3\n /\n4\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It\u2019s important to note that both DFS and BFS can solve ",(0,i.jsx)(n.code,{children:"reachability"})," problems, such as determining if one node is reachable from another. Many people prefer DFS for such problems because it can be quickly implemented using recursion. However, in practical software engineering, recursive implementations are rarely used because they are harder to understand and may cause stack overflow. Since iterative DFS (using a stack) and BFS (using a queue) have similar implementations, the choice between them depends on the specific requirements of the task. Additionally, if custom traversal priorities are needed, we can use priority queues, which will be discussed in the data structures section."]}),"\n",(0,i.jsx)(n.h2,{id:"1091-shortest-path-in-binary-matrix",children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/shortest-path-in-binary-matrix/",children:"1091. Shortest Path in Binary Matrix"})}),"\n",(0,i.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,i.jsxs)(n.p,{children:["Given a 2D binary matrix where ",(0,i.jsx)(n.code,{children:"1"})," represents obstacles and ",(0,i.jsx)(n.code,{children:"0"})," represents open paths, each position is connected to its eight neighbors. Find the shortest path from the top-left corner to the bottom-right corner. If there is no valid path, return ",(0,i.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,i.jsx)(n.p,{children:"Input is a 2D integer array, and the output is an integer representing the shortest distance."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input:\n[[0,0,1],\n [1,1,0],\n [1,1,0]]\nOutput: 4\n"})}),"\n",(0,i.jsx)(n.p,{children:"The shortest path is to move right first, then turn and move downward."}),"\n",(0,i.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,i.jsx)(n.p,{children:"Using a queue, we can intuitively apply Breadth-First Search (BFS) to determine the minimum number of layers to expand, i.e., the shortest path to the destination. Be careful not to revisit previously searched positions."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)(s,{value:"cpp",label:"C++",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\n    if (grid[0][0] == 1) {\n        return -1;\n    }\n    int m = grid.size(), n = grid[0].size();\n    int dist = 0, count;\n    queue<pair<int, int>> q;\n    q.push({0, 0});\n    grid[0][0] = -1;  // -1 indicates visited\n    count = q.size();\n    while (count > 0) {\n        ++dist;\n        while (count--) {\n            auto [r, c] = q.front();\n            q.pop();\n            if (r == m - 1 && c == n - 1) {\n                return dist;\n            }\n            for (int dx = -1; dx <= 1; ++dx) {\n                for (int dy = -1; dy <= 1; ++dy) {\n                    if (dx == 0 && dy == 0) {\n                        continue;\n                    }\n                    int x = r + dx, y = c + dy;\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] != 0) {\n                        continue;\n                    }\n                    grid[x][y] = -1;\n                    q.push({x, y});\n                }\n            }\n        }\n        count = q.size();\n    }\n    return -1;\n}\n"})})}),(0,i.jsx)(s,{value:"py",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"def shortestPathBinaryMatrix(grid: List[List[int]]) -> int:\n    if grid[0][0] == 1:\n        return -1\n    m, n = len(grid), len(grid[0])\n    dist = 0\n    q = collections.deque()\n    q.append((0, 0))\n    grid[0][0] = -1 # -1 indicates visited\n    count = len(q)\n    while count > 0:\n        dist += 1\n        while count > 0:\n            count -= 1\n            r, c = q.popleft()\n            if r == m - 1 and c == n - 1:\n                return dist\n            for dx in range(-1, 2):\n                for dy in range(-1, 2):\n                    if dx == 0 and dy == 0:\n                        continue\n                x, y = r + dx, c + dy\n                if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] != 0:\n                    continue\n                grid[x][y] = -1\n                q.append((x, y))\n        count = len(q)\n    return -1\n"})})})]}),"\n",(0,i.jsx)(n.h2,{id:"934-shortest-bridge",children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/shortest-bridge/",children:"934. Shortest Bridge"})}),"\n",(0,i.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,i.jsxs)(n.p,{children:["Given a 2D binary grid where ",(0,i.jsx)(n.code,{children:"1"})," represents land and ",(0,i.jsx)(n.code,{children:"0"})," represents water, each position is connected to its four neighbors. There are exactly two islands in the grid. Find the minimum number of water cells to convert into land to connect the two islands."]}),"\n",(0,i.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,i.jsx)(n.p,{children:"Input is a 2D integer grid, and the output is a non-negative integer representing the number of water cells to fill."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Input:\n[[1,1,1,1,1],\n [1,0,0,0,1],\n [1,0,1,0,1],\n [1,0,0,0,1],\n [1,1,1,1,1]]\nOutput: 1\n"})}),"\n",(0,i.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,i.jsx)(n.p,{children:"This problem can be solved by finding the shortest distance between the two islands. First, identify one of the islands using any search method, then use Breadth-First Search (BFS) to find the shortest distance to the other island. Below is the implementation using Depth-First Search (DFS) to find the first island."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)(s,{value:"cpp",label:"C++",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"vector<int> direction{-1, 0, 1, 0, -1};\n// Auxiliary function\n\nvoid dfs(queue<pair<int, int>>& points, vector<vector<int>>& grid, int i,\n         int j) {\n    int m = grid.size(), n = grid[0].size();\n    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 2) {\n        return;\n    }\n    if (grid[i][j] == 0) {\n        points.push({i, j});\n        return;\n    }\n    grid[i][j] = 2;\n    for (int k = 0; k < 4; ++k) {\n        dfs(points, grid, i + direction[k], j + direction[k + 1]);\n    }\n}\n\n// Main function\nint shortestBridge(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    queue<pair<int, int>> points;\n    // DFS to find the first island, and change all 1s to 2\n    bool flipped = false;\n    for (int i = 0; i < m && !flipped; ++i) {\n        for (int j = 0; j < n && !flipped; ++j) {\n            if (grid[i][j] == 1) {\n                dfs(points, grid, i, j);\n                flipped = true;\n            }\n        }\n    }\n    // BFS to find the second island, and change all 0s encountered to 2\n    int level = 0;\n    while (!points.empty()) {\n        ++level;\n        int n_points = points.size();\n        while (n_points--) {\n            auto [r, c] = points.front();\n            points.pop();\n            grid[r][c] = 2;\n            for (int k = 0; k < 4; ++k) {\n                int x = r + direction[k], y = c + direction[k + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n) {\n                    if (grid[x][y] == 2) {\n                        continue;\n                    }\n                    if (grid[x][y] == 1) {\n                        return level;\n                    }\n                    grid[x][y] = 2;\n                    points.push({x, y});\n                }\n            }\n        }\n    }\n    return 0;\n}\n"})})}),(0,i.jsx)(s,{value:"py",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"direction = [-1, 0, 1, 0, -1]\n\n# Auxiliary function\ndef dfs(points: Deque[Tuple[int, int]], grid: List[List[int]], i: int, j: int):\n    m, n = len(grid), len(grid[0])\n    if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 2:\n        return\n    if grid[i][j] == 0:\n        points.append((i, j))\n        return\n    grid[i][j] = 2\n    for k in range(4):\n        dfs(points, grid, i + direction[k], j + direction[k + 1])\n\ndef shortestBridge(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    points = collections.deque()\n    # DFS to find the first island, and change all 1s to 2\n    flipped = False\n    for i in range(m):\n        if flipped:\n            break\n        for j in range(n):\n            if grid[i][j] == 1:\n                dfs(points, grid, i, j)\n                flipped = True\n                break\n    # BFS to find the second island, and change all 0s encountered to 2\n    level = 0\n    while len(points) > 0:\n        level += 1\n        points_at_current_level = len(points)\n        for _ in range(points_at_current_level):\n            r, c = points.popleft()\n            grid[r][c] = 2\n            for k in range(4):\n                x, y = r + direction[k], c + direction[k + 1]\n                if x >= 0 and x < m and y >= 0 and y < n:\n                    if grid[x][y] == 2:\n                        continue\n                    if grid[x][y] == 1:\n                        return level\n                    grid[x][y] = 2\n                    points.append((x, y))\n    return level\n"})})})]}),"\n",(0,i.jsx)(n.h2,{id:"126-word-ladder-ii",children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/word-ladder-ii/",children:"126. Word Ladder II"})}),"\n",(0,i.jsx)(n.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,i.jsx)(n.p,{children:"Given a start string, an end string, and a word list, determine if you can transform the start string into the end string by changing one character at a time, where every intermediate string must exist in the word list. If possible, output all transformation sequences with the minimum number of changes."}),"\n",(0,i.jsx)(n.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,i.jsx)(n.p,{children:"Input consists of two strings and a word list, and the output is a 2D string array representing all transformation sequences."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: beginWord = "hit", endWord = "cog",\nwordList = ["hot","dot","dog","lot","log","cog"]\nOutput:\n[["hit","hot","dot","dog","cog"],\n ["hit","hot","lot","log","cog"]]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,i.jsx)(n.p,{children:"We can think of the start string, the end string, and all strings in the word list as nodes. If two strings differ by exactly one character, they are connected. Since the problem requires outputting all transformation sequences with the minimum number of changes, we can use breadth-first search (BFS) to compute the shortest path from the start node to the end node."}),"\n",(0,i.jsxs)(n.p,{children:["We also use a small optimization: instead of performing BFS only from the start node until the end node is found, we perform BFS from both the start node and the end node simultaneously. Each time, we extend the smaller frontier to minimize the total number of nodes explored. For example, if the shortest distance is 4, performing BFS from one end would explore up to ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"2"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"4"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"8"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"16"}),(0,i.jsx)(n.mo,{children:"="}),(0,i.jsx)(n.mn,{children:"31"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"1 + 2 + 4 + 8 + 16 = 31"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"2"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"4"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"8"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"16"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"31"})]})]})]})," nodes, while performing BFS from both ends for two levels would explore only ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"2"}),(0,i.jsx)(n.mo,{children:"\xd7"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"2"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"4"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"}),(0,i.jsx)(n.mo,{children:"="}),(0,i.jsx)(n.mn,{children:"14"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"2 \xd7 (1 + 2 + 4) = 14"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"2"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"\xd7"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,i.jsx)(n.span,{className:"mord",children:"2"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord",children:"4"}),(0,i.jsx)(n.span,{className:"mclose",children:")"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"14"})]})]})]})," nodes."]}),"\n",(0,i.jsx)(n.p,{children:"After completing the search, we use backtracking to reconstruct all possible paths."}),"\n",(0,i.jsx)(n.p,{children:"This problem is somewhat complex and requires careful thought and implementation. LeetCode's time constraints for this problem are very strict, so even the official solutions may sometimes time out. Multiple submissions may be necessary."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)(s,{value:"cpp",label:"C++",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// Auxiliary function\nvoid backtracking(const string &src, const string &dst,\n                  unordered_map<string, vector<string>> &next_words,\n                  vector<string> &path, vector<vector<string>> &ladder) {\n    if (src == dst) {\n        ladder.push_back(path);\n        return;\n    }\n    if (!next_words.contains(src)) {\n        return;\n    }\n    for (const auto &w : next_words[src]) {\n        path.push_back(w);  // Modify the current node state\n        backtracking(w, dst, next_words, path, ladder);  // Recursively process child nodes\n        path.pop_back();  // Revert the current node state\n    }\n}\n\n// Main function\nvector<vector<string>> findLadders(string beginWord, string endWord,\n                                   vector<string> &wordList) {\n    vector<vector<string>> ladder;\n    // Use a hash set to store the dictionary for quick lookups.\n    unordered_set<string> word_dict;\n    for (const auto &w : wordList) {\n        word_dict.insert(w);\n    }\n    if (!word_dict.contains(endWord)) {\n        return ladder;\n    }\n    word_dict.erase(beginWord);\n    word_dict.erase(endWord);\n    // Create two queues for bidirectional BFS from beginWord and endWord,\n    // expanding the smaller queue each time.\n    unordered_set<string> q_small{beginWord}, q_large{endWord};\n    unordered_map<string, vector<string>> next_words;\n    bool reversed_path = false, found_path = false;\n    while (!q_small.empty()) {\n        unordered_set<string> q;\n        for (const auto &w : q_small) {\n            string s = w;\n            for (int i = 0; i < s.size(); ++i) {\n                for (int j = 0; j < 26; ++j) {\n                    s[i] = j + 'a';\n                    if (q_large.contains(s)) {\n                        reversed_path ? next_words[s].push_back(w)\n                                      : next_words[w].push_back(s);\n                        found_path = true;\n                    }\n                    if (word_dict.contains(s)) {\n                        reversed_path ? next_words[s].push_back(w)\n                                      : next_words[w].push_back(s);\n                        q.insert(s);\n                    }\n                }\n                s[i] = w[i];\n            }\n        }\n        if (found_path) {\n            break;\n        }\n        // Avoid revisiting nodes and infinite loops.\n        for (const auto &w : q) {\n            word_dict.erase(w);\n        }\n        // Update the two queues and maintain size relationship.\n        if (q.size() <= q_large.size()) {\n            q_small = q;\n        } else {\n            reversed_path = !reversed_path;\n            q_small = q_large;\n            q_large = q;\n        }\n    }\n    if (found_path) {\n        vector<string> path{beginWord};\n        backtracking(beginWord, endWord, next_words, path, ladder);\n    }\n    return ladder;\n}\n"})})}),(0,i.jsx)(s,{value:"py",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:'# Auxiliary function\ndef backtracking(src: str, dst: str, next_words: Dict[str, List[str]],\n                 path: List[str], ladder: List[List[str]]):\n    if src == dst:\n        ladder.append(path[:])\n        return\n    if src not in next_words:\n        return\n    for w in next_words[src]:\n        path.append(w)  # Modify the current node state\n        backtracking(w, dst, next_words, path, ladder)  # Recurse to child nodes\n        path.pop()  # Revert the current node state\n\n# Main function\ndef findLadders(beginWord: str, endWord: str,\n              wordList: List[str]) -> List[List[str]]:\n    ladder = []\n    # Use a hash set to store the dictionary for quick lookups.\n    word_dict = set(wordList)\n    if endWord not in word_dict:\n        return ladder\n    word_dict = word_dict.difference(set([beginWord, endWord]))\n    # Create two queues for bidirectional BFS from beginWord and endWord,\n    # expanding the smaller queue each time.\n    q_small, q_large = set([beginWord]), set([endWord])\n    next_words = dict()\n    reversed_path, found_path = False, False\n    while len(q_small) > 0:\n        q = set()\n        for w in q_small:\n            for i in range(len(w)):\n                for j in range(26):\n                    s = w[:i] + chr(ord("a") + j) + w[i + 1:]\n                    if s in q_large:\n                        if reversed_path:\n                            next_words[s] = next_words.get(s, []) + [w]\n                        else:\n                            next_words[w] = next_words.get(w, []) + [s]\n                        found_path = True\n                    if s in word_dict:\n                        if reversed_path:\n                            next_words[s] = next_words.get(s, []) + [w]\n                        else:\n                            next_words[w] = next_words.get(w, []) + [s]\n                        q.add(s)\n        if found_path:\n            break\n        # Avoid revisiting nodes and infinite loops.\n        word_dict = word_dict.difference(q)\n        # Update the two queues and maintain size relationships.\n        if len(q) <= len(q_large):\n            q_small = q\n        else:\n            reversed_path = not reversed_path\n            q_small = q_large\n            q_large = q\n\n    if found_path:\n        path = [beginWord]\n        backtracking(beginWord, endWord, next_words, path, ladder)\n    return ladder\n'})})})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}function p(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);