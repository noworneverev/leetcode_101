"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[8741],{9339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"data-structures/10-4-stack-and-queue","title":"10.4 Stacks and Queues","description":"232. Implement Queue using Stacks","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/10-data-structures/10-4-stack-and-queue.mdx","sourceDirName":"10-data-structures","slug":"/data-structures/10-4-stack-and-queue","permalink":"/leetcode_101/en/data-structures/10-4-stack-and-queue","draft":false,"unlisted":false,"editUrl":"https://github.com/noworneverev/leetcode_101/tree/master/leetcode_101/docs/10-data-structures/10-4-stack-and-queue.mdx","tags":[],"version":"current","sidebarPosition":51,"frontMatter":{"sidebar_position":51},"sidebar":"tutorialSidebar","previous":{"title":"10.3 Arrays","permalink":"/leetcode_101/en/data-structures/10-3-arrays"},"next":{"title":"10.5 Monotonic Stack","permalink":"/leetcode_101/en/data-structures/10-5-monotonic-stack"}}');var i=t(4848),a=t(8453);const l={sidebar_position:51},r="10.4 Stacks and Queues",o={},c=[{value:"232. Implement Queue using Stacks",id:"232-implement-queue-using-stacks",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"155. Min Stack",id:"155-min-stack",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"20. Valid Parentheses",id:"20-valid-parentheses",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3}];function p(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,a.R)(),...e.components},{TabItem:t,Tabs:s}=n;return t||d("TabItem",!0),s||d("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"104-stacks-and-queues",children:"10.4 Stacks and Queues"})}),"\n",(0,i.jsx)(n.h2,{id:"232-implement-queue-using-stacks",children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/implement-queue-using-stacks/",children:"232. Implement Queue using Stacks"})}),"\n",(0,i.jsx)(n.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,i.jsx)(n.p,{children:"Try to implement a queue using stacks."}),"\n",(0,i.jsx)(n.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of how the data structure is used."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"MyQueue queue = new MyQueue();\nqueue.push(1);\nqueue.push(2);\nqueue.peek(); // returns 1\nqueue.pop(); // returns 1\nqueue.empty(); // returns false\n"})}),"\n",(0,i.jsx)(n.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,i.jsx)(n.p,{children:"We can implement a queue using two stacks: since we need a first-in-first-out result, we must reverse the array once using an additional stack. This reversing process can be completed either during insertion or during retrieval. Below is an example of implementing the reversal during retrieval."}),"\n",(0,i.jsxs)(s,{children:[(0,i.jsx)(t,{value:"cpp",label:"C++",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class MyQueue {\n   public:\n    MyQueue() {}\n\n    void push(int x) { s_in_.push(x); }\n\n    int pop() {\n        in2out();\n        int x = s_out_.top();\n        s_out_.pop();\n        return x;\n    }\n\n    int peek() {\n        in2out();\n        return s_out_.top();\n    }\n\n    bool empty() { return s_in_.empty() && s_out_.empty(); }\n\n   private:\n    void in2out() {\n        if (!s_out_.empty()) {\n            return;\n        }\n        while (!s_in_.empty()) {\n            int x = s_in_.top();\n            s_in_.pop();\n            s_out_.push(x);\n        }\n    }\n\n    stack<int> s_in_, s_out_;\n};\n"})})}),(0,i.jsx)(t,{value:"py",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"class MyQueue:\n    def __init__(self):\n        self.s_in = []\n        self.s_out = []\n\n    def _in2out(self):\n        if len(self.s_out) > 0:\n            return\n        while len(self.s_in) > 0:\n            self.s_out.append(self.s_in.pop())\n\n    def push(self, x: int) -> None:\n        self.s_in.append(x)\n\n    def pop(self) -> int:\n        self._in2out()\n        return self.s_out.pop()\n\n    def peek(self) -> int:\n        self._in2out()\n        return self.s_out[-1]\n\n    def empty(self) -> bool:\n        return len(self.s_in) == 0 and len(self.s_out) == 0\n"})})})]}),"\n",(0,i.jsx)(n.h2,{id:"155-min-stack",children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/min-stack/",children:"155. Min Stack"})}),"\n",(0,i.jsx)(n.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,i.jsxs)(n.p,{children:["Design a minimum stack that supports not only regular stack operations but also retrieving the minimum value in the stack in ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]})," time."]}),"\n",(0,i.jsx)(n.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of how the data structure is used."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // Returns -3.\nminStack.pop();\nminStack.top(); // Returns 0.\nminStack.getMin(); // Returns -2.\n"})}),"\n",(0,i.jsx)(n.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,i.jsx)(n.p,{children:"We can maintain an additional stack where the top represents the minimum value of all elements in the main stack. Every time a number is pushed onto the main stack, if it is less than or equal to the top of the auxiliary stack, it is also pushed onto the auxiliary stack, indicating it is a minimum value in the main stack. Similarly, every time a number is popped from the main stack, if it equals the top of the auxiliary stack, the top value of the auxiliary stack is also popped."}),"\n",(0,i.jsx)(n.p,{children:"An alternative method, which is simpler to write but has slightly higher time complexity, involves always pushing the minimum value of all elements in the main stack (the smaller of the top value of the auxiliary stack and the new value being pushed) onto the auxiliary stack. Similarly, every pop operation removes the top value from both stacks. This eliminates the need for conditionals but requires inserting and removing a value every time. Here, we only demonstrate the first approach."}),"\n",(0,i.jsxs)(s,{children:[(0,i.jsx)(t,{value:"cpp",label:"C++",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class MinStack {\n   public:\n    MinStack() {}\n\n    void push(int x) {\n        s_.push(x);\n        if (min_s_.empty() || min_s_.top() >= x) {\n            min_s_.push(x);\n        }\n    }\n\n    void pop() {\n        if (!min_s_.empty() && min_s_.top() == s_.top()) {\n            min_s_.pop();\n        }\n        s_.pop();\n    }\n\n    int top() { return s_.top(); }\n\n    int getMin() { return min_s_.top(); }\n\n   private:\n    stack<int> s_, min_s_;\n};\n"})})}),(0,i.jsx)(t,{value:"py",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:"class MinStack:\n    def __init__(self):\n        self.s = []\n        self.min_s = []\n\n    def push(self, x: int) -> None:\n        self.s.append(x)\n        if len(self.min_s) == 0 or self.min_s[-1] >= x:\n            self.min_s.append(x)\n\n    def pop(self) -> None:\n        if len(self.min_s) != 0 and self.s[-1] == self.min_s[-1]:\n            self.min_s.pop()\n        self.s.pop()\n\n    def top(self) -> int:\n        return self.s[-1]\n\n    def getMin(self) -> int:\n        return self.min_s[-1]\n"})})})]}),"\n",(0,i.jsx)(n.h2,{id:"20-valid-parentheses",children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/valid-parentheses/",children:"20. Valid Parentheses"})}),"\n",(0,i.jsx)(n.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,i.jsxs)(n.p,{children:["Given a string containing only the characters ",(0,i.jsx)(n.code,{children:"("}),", ",(0,i.jsx)(n.code,{children:")"}),", ",(0,i.jsx)(n.code,{children:"{"}),", ",(0,i.jsx)(n.code,{children:"}"}),", ",(0,i.jsx)(n.code,{children:"["}),", and ",(0,i.jsx)(n.code,{children:"]"}),", determine if the input string is valid. A valid string requires that every opening bracket has a corresponding closing bracket of the same type, and the substring enclosed by the brackets is also valid."]}),"\n",(0,i.jsx)(n.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,i.jsx)(n.p,{children:"The input is a string, and the output is a boolean value indicating whether the string is valid."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Input: "{[]}()"\nOutput: true\n'})}),"\n",(0,i.jsx)(n.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,i.jsx)(n.p,{children:"Parenthesis matching is a classic problem that can be solved using a stack. As we iterate through the string from left to right, we push every opening bracket onto the stack. When encountering a closing bracket, we check if it matches the top of the stack. If it matches, we pop the stack; otherwise, the string is invalid."}),"\n",(0,i.jsxs)(s,{children:[(0,i.jsx)(t,{value:"cpp",label:"C++",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"bool isValid(string s) {\n    stack<char> parsed;\n    unordered_map<char, int> matches{{\u2019(\u2019, \u2019)\u2019}, {\u2019{\u2019, \u2019}\u2019}, {\u2019[\u2019, \u2019]\u2019}};\n    for (char c : s) {\n        if (matches.contains(c)) {\n            parsed.push(c);\n            continue;\n        }\n        if (parsed.empty()) {\n            return false;\n        }\n        if (c != matches[parsed.top()]) {\n            return false;\n        }\n        parsed.pop();\n    }\n    return parsed.empty();\n}\n"})})}),(0,i.jsx)(t,{value:"py",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-py",children:'def isValid(s: str) -> bool:\n    parsed = []\n    matches = {"{": "}", "(": ")", "[": "]"}\n    for c in s:\n        if c in matches.keys():\n            parsed.append(c)\n            continue\n        if len(parsed) == 0:\n            return False\n        if c != matches[parsed[-1]]:\n            return False\n        parsed.pop()\n    return len(parsed) == 0\n'})})})]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}function d(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);