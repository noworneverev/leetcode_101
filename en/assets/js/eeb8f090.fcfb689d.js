"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[8670],{6451:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>s,contentTitle:()=>d,default:()=>l,frontMatter:()=>a,metadata:()=>c,toc:()=>o});const c=JSON.parse('{"id":"graphs/14-1-data-structure-introduction","title":"14.1 Data Structure Introduction","description":"As the third member of the pointer triumvirate, graphs are an advanced version of trees. A graph can be classified as directed or undirected, cyclic or acyclic, and connected or disconnected. A tree is essentially a connected, undirected, acyclic graph. Another common type of graph is the Directed Acyclic Graph (DAG).","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/14-graphs/14-1-data-structure-introduction.mdx","sourceDirName":"14-graphs","slug":"/graphs/14-1-data-structure-introduction","permalink":"/leetcode_101/en/graphs/14-1-data-structure-introduction","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":75,"frontMatter":{"sidebar_position":75},"sidebar":"tutorialSidebar","previous":{"title":"14. \u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e09\uff1a\u56fe","permalink":"/leetcode_101/en/category/14-\u6307\u9488\u4e09\u5251\u5ba2\u4e4b\u4e09\u56fe"},"next":{"title":"14.2 Bipartite Graph","permalink":"/leetcode_101/en/graphs/14-2-bipartite-graph"}}');var i=t(4848),n=t(8453);const a={sidebar_position:75},d="14.1 Data Structure Introduction",s={},o=[];function h(e){const r={code:"code",h1:"h1",header:"header",img:"img",p:"p",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"141-data-structure-introduction",children:"14.1 Data Structure Introduction"})}),"\n",(0,i.jsxs)(r.p,{children:["As the third member of the pointer triumvirate, graphs are an advanced version of trees. A ",(0,i.jsx)(r.code,{children:"graph"})," can be classified as directed or undirected, cyclic or acyclic, and connected or disconnected. A tree is essentially a connected, undirected, acyclic graph. Another common type of graph is the ",(0,i.jsx)(r.code,{children:"Directed Acyclic Graph (DAG)"}),"."]}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)("span",{style:{display:"block",width:"20%",margin:"0 auto"},children:(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:t(5797).A+"",width:"656",height:"1436"})})}),(0,i.jsx)("figcaption",{style:{textAlign:"center"},children:"Figure 14.1: Example of a Directed Acyclic Graph"})]}),"\n",(0,i.jsxs)(r.p,{children:["There are two common ways to represent a graph. Suppose there are ",(0,i.jsx)(r.code,{children:"n"})," nodes and ",(0,i.jsx)(r.code,{children:"m"})," edges in the graph. The first method is the ",(0,i.jsx)(r.code,{children:"adjacency matrix"}),": we can create an ",(0,i.jsx)(r.code,{children:"n \xd7 n"})," matrix ",(0,i.jsx)(r.code,{children:"G"}),", where ",(0,i.jsx)(r.code,{children:"G[i][j] = 1"})," if node ",(0,i.jsx)(r.code,{children:"i"})," is connected to node ",(0,i.jsx)(r.code,{children:"j"}),", and ",(0,i.jsx)(r.code,{children:"0"})," otherwise. For an undirected graph, the matrix is symmetric, i.e., ",(0,i.jsx)(r.code,{children:"G[i][j] = G[j][i]"}),". The second method is the ",(0,i.jsx)(r.code,{children:"adjacency list"}),": we can create an array of size ",(0,i.jsx)(r.code,{children:"n"}),", where each index ",(0,i.jsx)(r.code,{children:"i"})," stores an array or linked list representing the nodes connected to node ",(0,i.jsx)(r.code,{children:"i"}),". The adjacency matrix requires more memory but allows for faster edge lookup, whereas the adjacency list is more space-efficient but does not support quick edge existence checks. Additionally, we can use an ",(0,i.jsx)(r.code,{children:"m \xd7 2"})," matrix to store all the edges directly."]})]})}function l(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},5797:(e,r,t)=>{t.d(r,{A:()=>c});const c=t.p+"assets/images/14.1-f1262a8972700eb464acbf1058e13eed.png"}}]);