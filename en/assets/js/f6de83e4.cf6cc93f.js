"use strict";(self.webpackChunkleetcode_101=self.webpackChunkleetcode_101||[]).push([[10],{168:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"trees/13-2-tree-recursion","title":"13.2 Tree Recursion","description":"For simple recursion problems, some LeetCode experts prefer to write one-line code, solving problems with a single line. While we will showcase such solutions, beginners are still advised to use multi-line if-else statements.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/13-trees/13-2-tree-recursion.mdx","sourceDirName":"13-trees","slug":"/trees/13-2-tree-recursion","permalink":"/leetcode_101/en/trees/13-2-tree-recursion","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":69,"frontMatter":{"sidebar_position":69},"sidebar":"tutorialSidebar","previous":{"title":"13.1 Data Structure Introduction","permalink":"/leetcode_101/en/trees/13-1-data-structure-introduction"},"next":{"title":"13.3 Level Order Traversal","permalink":"/leetcode_101/en/trees/13-3-level-order-traversal"}}');var i=n(4848),o=n(8453);const l={sidebar_position:69},a="13.2 Tree Recursion",s={},d=[{value:"104. Maximum Depth of Binary Tree",id:"104-maximum-depth-of-binary-tree",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Input and Output Example",id:"input-and-output-example",level:3},{value:"Solution Explanation",id:"solution-explanation",level:3},{value:"110. Balanced Binary Tree",id:"110-balanced-binary-tree",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Input and Output Example",id:"input-and-output-example-1",level:3},{value:"Solution Explanation",id:"solution-explanation-1",level:3},{value:"543. Diameter of Binary Tree",id:"543-diameter-of-binary-tree",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Input and Output Example",id:"input-and-output-example-2",level:3},{value:"Solution Explanation",id:"solution-explanation-2",level:3},{value:"437. Path Sum III",id:"437-path-sum-iii",level:2},{value:"Problem Description",id:"problem-description-3",level:3},{value:"Input and Output Example",id:"input-and-output-example-3",level:3},{value:"Solution Explanation",id:"solution-explanation-3",level:3},{value:"101. Symmetric Tree",id:"101-symmetric-tree",level:2},{value:"Problem Description",id:"problem-description-4",level:3},{value:"Input and Output Example",id:"input-and-output-example-4",level:3},{value:"Solution Explanation",id:"solution-explanation-4",level:3},{value:"1110. Delete Nodes And Return Forest",id:"1110-delete-nodes-and-return-forest",level:2},{value:"Problem Description",id:"problem-description-5",level:3},{value:"Input and Output Example",id:"input-and-output-example-5",level:3},{value:"Solution Explanation",id:"solution-explanation-5",level:3}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components},{TabItem:n,Tabs:r}=t;return n||p("TabItem",!0),r||p("Tabs",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"132-tree-recursion",children:"13.2 Tree Recursion"})}),"\n",(0,i.jsx)(t.p,{children:"For simple recursion problems, some LeetCode experts prefer to write one-line code, solving problems with a single line. While we will showcase such solutions, beginners are still advised to use multi-line if-else statements."}),"\n",(0,i.jsx)(t.p,{children:"In many cases, the recursive implementation for trees is similar to the recursive implementation for depth-first search. Hence, this book does not differentiate between the two."}),"\n",(0,i.jsx)(t.h2,{id:"104-maximum-depth-of-binary-tree",children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/maximum-depth-of-binary-tree/",children:"104. Maximum Depth of Binary Tree"})}),"\n",(0,i.jsx)(t.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,i.jsx)(t.p,{children:"Find the maximum depth of a binary tree."}),"\n",(0,i.jsx)(t.h3,{id:"input-and-output-example",children:"Input and Output Example"}),"\n",(0,i.jsx)(t.p,{children:"The input is a binary tree, and the output is an integer representing the maximum depth of the tree."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input:\n    3\n   / \\\n  9  20\n     / \\\n    15  7\nOutput: 3\n"})}),"\n",(0,i.jsx)(t.h3,{id:"solution-explanation",children:"Solution Explanation"}),"\n",(0,i.jsx)(t.p,{children:"Using recursion, we can easily determine the maximum depth."}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"int maxDepth(TreeNode* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n}\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"def maxDepth(root: Optional[TreeNode]) -> int:\n    if root is None:\n        return 0\n    return max(maxDepth(root.left), maxDepth(root.right)) + 1\n"})})})]}),"\n",(0,i.jsx)(t.h2,{id:"110-balanced-binary-tree",children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/balanced-binary-tree/",children:"110. Balanced Binary Tree"})}),"\n",(0,i.jsx)(t.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,i.jsx)(t.p,{children:"Determine whether a binary tree is balanced. A balanced tree is defined as a tree in which the maximum depth difference between any two child nodes of a node is no greater than 1."}),"\n",(0,i.jsx)(t.h3,{id:"input-and-output-example-1",children:"Input and Output Example"}),"\n",(0,i.jsx)(t.p,{children:"The input is a binary tree, and the output is a boolean indicating whether the tree is balanced."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input:\n      1\n     / \\\n    2   2\n   / \\\n  3   3\n / \\\n4   4 \nOutput: false\n"})}),"\n",(0,i.jsx)(t.h3,{id:"solution-explanation-1",children:"Solution Explanation"}),"\n",(0,i.jsx)(t.p,{children:"The solution is similar to calculating the maximum depth of a tree but with two key differences:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The depth of the subtrees must be calculated first before performing the comparison."}),"\n",(0,i.jsx)(t.li,{children:"If an imbalance is detected while processing a subtree, return -1 immediately to signal imbalance. This allows ancestor nodes to avoid redundant checks. (In this problem, determining imbalance is straightforward by taking the absolute difference, but avoiding redundant computations is crucial in scenarios involving more costly comparisons.)"}),"\n"]}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Auxiliary function\nint balancedDepth(TreeNode* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    int left = balancedDepth(root->left);\n    int right = balancedDepth(root->right);\n    if (left == -1 || right == -1 || abs(left - right) > 1) {\n        return -1;\n    }\n    return max(left, right) + 1;\n}\n// Main function\nbool isBalanced(TreeNode* root) { return balancedDepth(root) != -1; }\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"# Auxiliary function\ndef balancedDepth(root: Optional[TreeNode]) -> int:\n    if root is None:\n        return 0\n    left = balancedDepth(root.left)\n    right = balancedDepth(root.right)\n    if left == -1 or right == -1 or abs(left - right) > 1:\n        return -1\n    return max(left, right) + 1\n\n# Main function\ndef isBalanced(root: Optional[TreeNode]) -> bool:\n    return balancedDepth(root) != -1\n\n"})})})]}),"\n",(0,i.jsx)(t.h2,{id:"543-diameter-of-binary-tree",children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/diameter-of-binary-tree/",children:"543. Diameter of Binary Tree"})}),"\n",(0,i.jsx)(t.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,i.jsx)(t.p,{children:"Find the longest diameter of a binary tree. The diameter is defined as the undirected distance between any two nodes in the binary tree."}),"\n",(0,i.jsx)(t.h3,{id:"input-and-output-example-2",children:"Input and Output Example"}),"\n",(0,i.jsx)(t.p,{children:"Input is a binary tree, and output is an integer representing the longest diameter."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input:\n      1\n     / \\\n    2   3\n   / \\\n  4   5\nOutput: 3\n"})}),"\n",(0,i.jsx)(t.p,{children:"In this example, the longest diameter is [4,2,1,3] and [5,2,1,3]."}),"\n",(0,i.jsx)(t.h3,{id:"solution-explanation-2",children:"Solution Explanation"}),"\n",(0,i.jsx)(t.p,{children:"We can use recursion to solve this problem. It's important to note that when processing a subtree, the updated longest diameter and the returned value from the recursion are different."}),"\n",(0,i.jsx)(t.p,{children:"The updated longest diameter refers to the diameter passing through the root of the subtree (i.e., the sum of the lengths of the left and right subtrees). The function's return value, however, is the longest diameter with the root of the subtree as an endpoint (i.e., the length of one side of the subtree). This return value design allows the parent node's longest diameter to be updated recursively."}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Auxiliary function\nint updateDiameter(TreeNode* node, int& diameter) {\n    if (node == nullptr) {\n        return 0;\n    }\n    int left = updateDiameter(node->left, diameter);\n    int right = updateDiameter(node->right, diameter);\n    diameter = max(diameter, left + right);\n    return max(left, right) + 1;\n}\n// Main function\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n    updateDiameter(root, diameter);\n    return diameter;\n}\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"# Auxiliary function\ndef updateDiameter(node: Optional[TreeNode], diameter: List[int]) -> int:\n    if node is None:\n        return 0\n    left = updateDiameter(node.left, diameter)\n    right = updateDiameter(node.right, diameter)\n    diameter[0] = max(diameter[0], left + right)\n    return max(left, right) + 1\n\n# Main function\ndef diameterOfBinaryTree(root: Optional[TreeNode]) -> int:\n    diameter = [0]\n    updateDiameter(root, diameter)\n    return diameter[0]\n\n"})})})]}),"\n",(0,i.jsx)(t.h2,{id:"437-path-sum-iii",children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/path-sum-iii/",children:"437. Path Sum III"})}),"\n",(0,i.jsx)(t.h3,{id:"problem-description-3",children:"Problem Description"}),"\n",(0,i.jsx)(t.p,{children:"Given a binary tree of integers, find the number of paths where the sum of the node values equals a given target."}),"\n",(0,i.jsx)(t.h3,{id:"input-and-output-example-3",children:"Input and Output Example"}),"\n",(0,i.jsx)(t.p,{children:"Input is a binary tree and a target integer. Output is an integer representing the number of paths that satisfy the condition."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input: sum = 8, tree =\n        10\n       / \\\n      5  -3\n     / \\   \\\n    3   2   11\n   / \\   \\\n  3 -2    1\nOutput: 3\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In this example, there are three paths where the sum equals 8: ",(0,i.jsx)(t.code,{children:"[[5,3],[5,2,1],[-3,11]]"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"solution-explanation-3",children:"Solution Explanation"}),"\n",(0,i.jsx)(t.p,{children:"When recursively processing each node, consider two scenarios:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"If the current node is included in the path, subsequent nodes must be added continuously, or the path stops."}),"\n",(0,i.jsx)(t.li,{children:"If the current node is not included, restart the path calculation from its left and right children."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"A convenient way to handle this is to create an auxiliary function specifically for calculating paths that start from the current node."}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Auxiliary function\n// Use long long to prevent overflow with large test cases; int is usually sufficient.\nlong long pathSumStartWithRoot(TreeNode* root, long long targetSum) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return (root->val == targetSum) +\n           pathSumStartWithRoot(root->left, targetSum - root->val) +\n           pathSumStartWithRoot(root->right, targetSum - root->val);\n}\n// Main function\nint pathSum(TreeNode* root, int targetSum) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return pathSumStartWithRoot(root, targetSum) +\n           pathSum(root->left, targetSum) + pathSum(root->right, targetSum);\n}\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"# Auxiliary function\ndef pathSumStartWithRoot(root: Optional[TreeNode], targetSum: int) -> int:\n    if root is None:\n        return 0\n    return (\n        int(root.val == targetSum)\n        + pathSumStartWithRoot(root.left, targetSum - root.val)\n        + pathSumStartWithRoot(root.right, targetSum - root.val)\n    )\n\n# Main function\ndef pathSum(root: Optional[TreeNode], targetSum: int) -> int:\n    if root is None:\n        return 0\n    return (\n        pathSumStartWithRoot(root, targetSum)\n        + pathSum(root.left, targetSum)\n        + pathSum(root.right, targetSum)\n    )\n\n"})})})]}),"\n",(0,i.jsx)(t.h2,{id:"101-symmetric-tree",children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/symmetric-tree/",children:"101. Symmetric Tree"})}),"\n",(0,i.jsx)(t.h3,{id:"problem-description-4",children:"Problem Description"}),"\n",(0,i.jsx)(t.p,{children:"Determine whether a binary tree is symmetric."}),"\n",(0,i.jsx)(t.h3,{id:"input-and-output-example-4",children:"Input and Output Example"}),"\n",(0,i.jsx)(t.p,{children:"Input a binary tree, output a boolean indicating whether the tree is symmetric."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input:\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4 3\nOutput: true\n"})}),"\n",(0,i.jsx)(t.h3,{id:"solution-explanation-4",children:"Solution Explanation"}),"\n",(0,i.jsx)(t.p,{children:'Determining whether a tree is symmetric is equivalent to checking if its left and right subtrees are symmetric. A common approach for such problems is the "four-step method":'}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"If both subtrees are null, they are symmetric."}),"\n",(0,i.jsx)(t.li,{children:"If one subtree is null and the other is not, they are not symmetric."}),"\n",(0,i.jsx)(t.li,{children:"If the root values of the two subtrees are not equal, they are not symmetric."}),"\n",(0,i.jsx)(t.li,{children:"Based on symmetry requirements, recursively process the subtrees."}),"\n"]}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Auxiliary function\nbool isLeftRightSymmetric(TreeNode* left, TreeNode* right) {\n    if (left == nullptr && right == nullptr) {\n        return true;\n    }\n    if (left == nullptr or right == nullptr) {\n        return false;\n    }\n    if (left->val != right->val) {\n        return false;\n    }\n    return isLeftRightSymmetric(left->left, right->right) &&\n           isLeftRightSymmetric(left->right, right->left);\n}\n// Main function\nbool isSymmetric(TreeNode* root) {\n    if (root == nullptr) {\n        return true;\n    }\n    return isLeftRightSymmetric(root->left, root->right);\n}\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"# Auxiliary function\ndef isLeftRightSymmetric(\n    left: Optional[TreeNode], right: Optional[TreeNode]\n) -> bool:\n    if left is None and right is None:\n        return True\n    if left is None or right is None:\n        return False\n    if left.val != right.val:\n        return False\n    return (\n        isLeftRightSymmetric(left.left, right.right) and\n        isLeftRightSymmetric(left.right, right.left)\n    )\n\n# Main function\ndef isSymmetric(root: Optional[TreeNode]) -> bool:\n    if root is None:\n        return True\n    return isLeftRightSymmetric(root.left, root.right)\n\n"})})})]}),"\n",(0,i.jsx)(t.h2,{id:"1110-delete-nodes-and-return-forest",children:(0,i.jsx)(t.a,{href:"https://leetcode.com/problems/delete-nodes-and-return-forest/",children:"1110. Delete Nodes And Return Forest"})}),"\n",(0,i.jsx)(t.h3,{id:"problem-description-5",children:"Problem Description"}),"\n",(0,i.jsx)(t.p,{children:"Given an integer binary tree and some integers, delete the nodes corresponding to these integers and return the remaining subtrees."}),"\n",(0,i.jsx)(t.h3,{id:"input-and-output-example-5",children:"Input and Output Example"}),"\n",(0,i.jsx)(t.p,{children:"Input is an integer binary tree and a one-dimensional integer array. Output is an array where each position contains a subtree (its root node)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Input: to_delete = [3,5], tree =\n    1\n   / \\\n  2   3\n / \\ / \\\n 4 5 6 7\nOutput: [\n    1\n   /\n  2\n /\n4  ,6 ,7]\n"})}),"\n",(0,i.jsx)(t.h3,{id:"solution-explanation-5",children:"Solution Explanation"}),"\n",(0,i.jsx)(t.p,{children:"The key details in this problem include how to recursively handle the original tree and when to disconnect pointers. Additionally, to efficiently find nodes to delete, you can create a hash table for quick lookup. It is highly recommended that readers attempt to implement this problem after reviewing the solution to deepen their understanding and application of recursion."}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)(n,{value:"cpp",label:"C++",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"// Auxiliary function\nTreeNode* moveNodesToForest(TreeNode* root, unordered_set<int>& undeleted,\n                            vector<TreeNode*>& forest) {\n    if (root == nullptr) {\n        return nullptr;\n    }\n    root->left = moveNodesToForest(root->left, undeleted, forest);\n    root->right = moveNodesToForest(root->right, undeleted, forest);\n    if (undeleted.contains(root->val)) {\n        if (root->left != nullptr) {\n            forest.push_back(root->left);\n        }\n        if (root->right != nullptr) {\n            forest.push_back(root->right);\n        }\n        root = nullptr;\n    }\n    return root;\n}\n// Main function\nvector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n    vector<TreeNode*> forest;\n    unordered_set<int> undeleted(to_delete.begin(), to_delete.end());\n    root = moveNodesToForest(root, undeleted, forest);\n    if (root != nullptr) {\n        forest.push_back(root);\n    }\n    return forest;\n}\n"})})}),(0,i.jsx)(n,{value:"py",label:"Python",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-py",children:"# Auxiliary function\ndef moveNodesToForest(\n    root: Optional[TreeNode], undeleted: Set[int], forest: List[TreeNode]\n) -> Optional[TreeNode]:\n    if root is None:\n        return None\n    \n    root.left = moveNodesToForest(root.left, undeleted, forest)\n    root.right = moveNodesToForest(root.right, undeleted, forest)\n    \n    if root.val in undeleted:\n        if root.left is not None:\n            forest.append(root.left)\n        if root.right is not None:\n            forest.append(root.right)\n        root = None\n    \n    return root\n\n# Main function\ndef delNodes(root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:\n    forest = []\n    undeleted = set(to_delete)\n    root = moveNodesToForest(root, undeleted, forest)\n    if root is not None:\n        forest.append(root)\n    return forest\n\n"})})})]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}function p(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);